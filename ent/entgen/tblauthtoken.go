// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"fmt"
	"inventory/ent/entgen/tblauthclient"
	"inventory/ent/entgen/tblauthtoken"
	"inventory/ent/entgen/tbluser"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// TblAuthToken is the model entity for the TblAuthToken schema.
type TblAuthToken struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// AuthUUID holds the value of the "auth_uuid" field.
	AuthUUID string `json:"auth_uuid,omitempty"`
	// AuthXref holds the value of the "auth_xref" field.
	AuthXref string `json:"auth_xref,omitempty"`
	// Accesstoken holds the value of the "accesstoken" field.
	Accesstoken string `json:"accesstoken,omitempty"`
	// Accesstokencreatedat holds the value of the "accesstokencreatedat" field.
	Accesstokencreatedat time.Time `json:"accesstokencreatedat,omitempty"`
	// Accesstokenexpiresin holds the value of the "accesstokenexpiresin" field.
	Accesstokenexpiresin int `json:"accesstokenexpiresin,omitempty"`
	// Clientid holds the value of the "clientid" field.
	Clientid string `json:"clientid,omitempty"`
	// UserUlid holds the value of the "user_ulid" field.
	UserUlid string `json:"user_ulid,omitempty"`
	// Refreshtoken holds the value of the "refreshtoken" field.
	Refreshtoken string `json:"refreshtoken,omitempty"`
	// Refreshtokencreatedat holds the value of the "refreshtokencreatedat" field.
	Refreshtokencreatedat time.Time `json:"refreshtokencreatedat,omitempty"`
	// Refreshtokenexpiresin holds the value of the "refreshtokenexpiresin" field.
	Refreshtokenexpiresin int `json:"refreshtokenexpiresin,omitempty"`
	// Createdat holds the value of the "createdat" field.
	Createdat time.Time `json:"createdat,omitempty"`
	// Updatedat holds the value of the "updatedat" field.
	Updatedat time.Time `json:"updatedat,omitempty"`
	// Deletedat holds the value of the "deletedat" field.
	Deletedat *time.Time `json:"deletedat,omitempty"`
	// IPAddress holds the value of the "ip_address" field.
	IPAddress string `json:"ip_address,omitempty"`
	// Useragent holds the value of the "useragent" field.
	Useragent string `json:"useragent,omitempty"`
	// Createdby holds the value of the "createdby" field.
	Createdby string `json:"createdby,omitempty"`
	// Updatedby holds the value of the "updatedby" field.
	Updatedby string `json:"updatedby,omitempty"`
	// Deletedby holds the value of the "deletedby" field.
	Deletedby *string `json:"deletedby,omitempty"`
	// Code holds the value of the "code" field.
	Code string `json:"code,omitempty"`
	// Codecreatedat holds the value of the "codecreatedat" field.
	Codecreatedat time.Time `json:"codecreatedat,omitempty"`
	// Codeexpiresin holds the value of the "codeexpiresin" field.
	Codeexpiresin int `json:"codeexpiresin,omitempty"`
	// Codechallenge holds the value of the "codechallenge" field.
	Codechallenge *string `json:"codechallenge,omitempty"`
	// RedirectURI holds the value of the "redirect_uri" field.
	RedirectURI *string `json:"redirect_uri,omitempty"`
	// Scope holds the value of the "scope" field.
	Scope string `json:"scope,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the TblAuthTokenQuery when eager-loading is set.
	Edges        TblAuthTokenEdges `json:"edges"`
	selectValues sql.SelectValues
}

// TblAuthTokenEdges holds the relations/edges for other nodes in the graph.
type TblAuthTokenEdges struct {
	// TokenClient holds the value of the TokenClient edge.
	TokenClient *TblAuthClient `json:"TokenClient,omitempty"`
	// TokenUser holds the value of the TokenUser edge.
	TokenUser *TblUser `json:"TokenUser,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// TokenClientOrErr returns the TokenClient value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TblAuthTokenEdges) TokenClientOrErr() (*TblAuthClient, error) {
	if e.TokenClient != nil {
		return e.TokenClient, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: tblauthclient.Label}
	}
	return nil, &NotLoadedError{edge: "TokenClient"}
}

// TokenUserOrErr returns the TokenUser value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e TblAuthTokenEdges) TokenUserOrErr() (*TblUser, error) {
	if e.TokenUser != nil {
		return e.TokenUser, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: tbluser.Label}
	}
	return nil, &NotLoadedError{edge: "TokenUser"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*TblAuthToken) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case tblauthtoken.FieldAccesstokenexpiresin, tblauthtoken.FieldRefreshtokenexpiresin, tblauthtoken.FieldCodeexpiresin:
			values[i] = new(sql.NullInt64)
		case tblauthtoken.FieldID, tblauthtoken.FieldAuthUUID, tblauthtoken.FieldAuthXref, tblauthtoken.FieldAccesstoken, tblauthtoken.FieldClientid, tblauthtoken.FieldUserUlid, tblauthtoken.FieldRefreshtoken, tblauthtoken.FieldIPAddress, tblauthtoken.FieldUseragent, tblauthtoken.FieldCreatedby, tblauthtoken.FieldUpdatedby, tblauthtoken.FieldDeletedby, tblauthtoken.FieldCode, tblauthtoken.FieldCodechallenge, tblauthtoken.FieldRedirectURI, tblauthtoken.FieldScope:
			values[i] = new(sql.NullString)
		case tblauthtoken.FieldAccesstokencreatedat, tblauthtoken.FieldRefreshtokencreatedat, tblauthtoken.FieldCreatedat, tblauthtoken.FieldUpdatedat, tblauthtoken.FieldDeletedat, tblauthtoken.FieldCodecreatedat:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the TblAuthToken fields.
func (tat *TblAuthToken) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case tblauthtoken.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				tat.ID = value.String
			}
		case tblauthtoken.FieldAuthUUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field auth_uuid", values[i])
			} else if value.Valid {
				tat.AuthUUID = value.String
			}
		case tblauthtoken.FieldAuthXref:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field auth_xref", values[i])
			} else if value.Valid {
				tat.AuthXref = value.String
			}
		case tblauthtoken.FieldAccesstoken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field accesstoken", values[i])
			} else if value.Valid {
				tat.Accesstoken = value.String
			}
		case tblauthtoken.FieldAccesstokencreatedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field accesstokencreatedat", values[i])
			} else if value.Valid {
				tat.Accesstokencreatedat = value.Time
			}
		case tblauthtoken.FieldAccesstokenexpiresin:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field accesstokenexpiresin", values[i])
			} else if value.Valid {
				tat.Accesstokenexpiresin = int(value.Int64)
			}
		case tblauthtoken.FieldClientid:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field clientid", values[i])
			} else if value.Valid {
				tat.Clientid = value.String
			}
		case tblauthtoken.FieldUserUlid:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field user_ulid", values[i])
			} else if value.Valid {
				tat.UserUlid = value.String
			}
		case tblauthtoken.FieldRefreshtoken:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field refreshtoken", values[i])
			} else if value.Valid {
				tat.Refreshtoken = value.String
			}
		case tblauthtoken.FieldRefreshtokencreatedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field refreshtokencreatedat", values[i])
			} else if value.Valid {
				tat.Refreshtokencreatedat = value.Time
			}
		case tblauthtoken.FieldRefreshtokenexpiresin:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field refreshtokenexpiresin", values[i])
			} else if value.Valid {
				tat.Refreshtokenexpiresin = int(value.Int64)
			}
		case tblauthtoken.FieldCreatedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field createdat", values[i])
			} else if value.Valid {
				tat.Createdat = value.Time
			}
		case tblauthtoken.FieldUpdatedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updatedat", values[i])
			} else if value.Valid {
				tat.Updatedat = value.Time
			}
		case tblauthtoken.FieldDeletedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deletedat", values[i])
			} else if value.Valid {
				tat.Deletedat = new(time.Time)
				*tat.Deletedat = value.Time
			}
		case tblauthtoken.FieldIPAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ip_address", values[i])
			} else if value.Valid {
				tat.IPAddress = value.String
			}
		case tblauthtoken.FieldUseragent:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field useragent", values[i])
			} else if value.Valid {
				tat.Useragent = value.String
			}
		case tblauthtoken.FieldCreatedby:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field createdby", values[i])
			} else if value.Valid {
				tat.Createdby = value.String
			}
		case tblauthtoken.FieldUpdatedby:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updatedby", values[i])
			} else if value.Valid {
				tat.Updatedby = value.String
			}
		case tblauthtoken.FieldDeletedby:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field deletedby", values[i])
			} else if value.Valid {
				tat.Deletedby = new(string)
				*tat.Deletedby = value.String
			}
		case tblauthtoken.FieldCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field code", values[i])
			} else if value.Valid {
				tat.Code = value.String
			}
		case tblauthtoken.FieldCodecreatedat:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field codecreatedat", values[i])
			} else if value.Valid {
				tat.Codecreatedat = value.Time
			}
		case tblauthtoken.FieldCodeexpiresin:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field codeexpiresin", values[i])
			} else if value.Valid {
				tat.Codeexpiresin = int(value.Int64)
			}
		case tblauthtoken.FieldCodechallenge:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field codechallenge", values[i])
			} else if value.Valid {
				tat.Codechallenge = new(string)
				*tat.Codechallenge = value.String
			}
		case tblauthtoken.FieldRedirectURI:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field redirect_uri", values[i])
			} else if value.Valid {
				tat.RedirectURI = new(string)
				*tat.RedirectURI = value.String
			}
		case tblauthtoken.FieldScope:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field scope", values[i])
			} else if value.Valid {
				tat.Scope = value.String
			}
		default:
			tat.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the TblAuthToken.
// This includes values selected through modifiers, order, etc.
func (tat *TblAuthToken) Value(name string) (ent.Value, error) {
	return tat.selectValues.Get(name)
}

// QueryTokenClient queries the "TokenClient" edge of the TblAuthToken entity.
func (tat *TblAuthToken) QueryTokenClient() *TblAuthClientQuery {
	return NewTblAuthTokenClient(tat.config).QueryTokenClient(tat)
}

// QueryTokenUser queries the "TokenUser" edge of the TblAuthToken entity.
func (tat *TblAuthToken) QueryTokenUser() *TblUserQuery {
	return NewTblAuthTokenClient(tat.config).QueryTokenUser(tat)
}

// Update returns a builder for updating this TblAuthToken.
// Note that you need to call TblAuthToken.Unwrap() before calling this method if this TblAuthToken
// was returned from a transaction, and the transaction was committed or rolled back.
func (tat *TblAuthToken) Update() *TblAuthTokenUpdateOne {
	return NewTblAuthTokenClient(tat.config).UpdateOne(tat)
}

// Unwrap unwraps the TblAuthToken entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (tat *TblAuthToken) Unwrap() *TblAuthToken {
	_tx, ok := tat.config.driver.(*txDriver)
	if !ok {
		panic("entgen: TblAuthToken is not a transactional entity")
	}
	tat.config.driver = _tx.drv
	return tat
}

// String implements the fmt.Stringer.
func (tat *TblAuthToken) String() string {
	var builder strings.Builder
	builder.WriteString("TblAuthToken(")
	builder.WriteString(fmt.Sprintf("id=%v, ", tat.ID))
	builder.WriteString("auth_uuid=")
	builder.WriteString(tat.AuthUUID)
	builder.WriteString(", ")
	builder.WriteString("auth_xref=")
	builder.WriteString(tat.AuthXref)
	builder.WriteString(", ")
	builder.WriteString("accesstoken=")
	builder.WriteString(tat.Accesstoken)
	builder.WriteString(", ")
	builder.WriteString("accesstokencreatedat=")
	builder.WriteString(tat.Accesstokencreatedat.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("accesstokenexpiresin=")
	builder.WriteString(fmt.Sprintf("%v", tat.Accesstokenexpiresin))
	builder.WriteString(", ")
	builder.WriteString("clientid=")
	builder.WriteString(tat.Clientid)
	builder.WriteString(", ")
	builder.WriteString("user_ulid=")
	builder.WriteString(tat.UserUlid)
	builder.WriteString(", ")
	builder.WriteString("refreshtoken=")
	builder.WriteString(tat.Refreshtoken)
	builder.WriteString(", ")
	builder.WriteString("refreshtokencreatedat=")
	builder.WriteString(tat.Refreshtokencreatedat.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("refreshtokenexpiresin=")
	builder.WriteString(fmt.Sprintf("%v", tat.Refreshtokenexpiresin))
	builder.WriteString(", ")
	builder.WriteString("createdat=")
	builder.WriteString(tat.Createdat.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updatedat=")
	builder.WriteString(tat.Updatedat.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := tat.Deletedat; v != nil {
		builder.WriteString("deletedat=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("ip_address=")
	builder.WriteString(tat.IPAddress)
	builder.WriteString(", ")
	builder.WriteString("useragent=")
	builder.WriteString(tat.Useragent)
	builder.WriteString(", ")
	builder.WriteString("createdby=")
	builder.WriteString(tat.Createdby)
	builder.WriteString(", ")
	builder.WriteString("updatedby=")
	builder.WriteString(tat.Updatedby)
	builder.WriteString(", ")
	if v := tat.Deletedby; v != nil {
		builder.WriteString("deletedby=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("code=")
	builder.WriteString(tat.Code)
	builder.WriteString(", ")
	builder.WriteString("codecreatedat=")
	builder.WriteString(tat.Codecreatedat.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("codeexpiresin=")
	builder.WriteString(fmt.Sprintf("%v", tat.Codeexpiresin))
	builder.WriteString(", ")
	if v := tat.Codechallenge; v != nil {
		builder.WriteString("codechallenge=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	if v := tat.RedirectURI; v != nil {
		builder.WriteString("redirect_uri=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("scope=")
	builder.WriteString(tat.Scope)
	builder.WriteByte(')')
	return builder.String()
}

// TblAuthTokens is a parsable slice of TblAuthToken.
type TblAuthTokens []*TblAuthToken
