// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"inventory/ent/entgen/migrate"

	"inventory/ent/entgen/tblauthclient"
	"inventory/ent/entgen/tblauthtoken"
	"inventory/ent/entgen/tblcart"
	"inventory/ent/entgen/tblinventory"
	"inventory/ent/entgen/tblinventorytag"
	"inventory/ent/entgen/tblpayment"
	"inventory/ent/entgen/tbltag"
	"inventory/ent/entgen/tbluser"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// TblAuthClient is the client for interacting with the TblAuthClient builders.
	TblAuthClient *TblAuthClientClient
	// TblAuthToken is the client for interacting with the TblAuthToken builders.
	TblAuthToken *TblAuthTokenClient
	// TblCart is the client for interacting with the TblCart builders.
	TblCart *TblCartClient
	// TblInventory is the client for interacting with the TblInventory builders.
	TblInventory *TblInventoryClient
	// TblInventoryTag is the client for interacting with the TblInventoryTag builders.
	TblInventoryTag *TblInventoryTagClient
	// TblPayment is the client for interacting with the TblPayment builders.
	TblPayment *TblPaymentClient
	// TblTag is the client for interacting with the TblTag builders.
	TblTag *TblTagClient
	// TblUser is the client for interacting with the TblUser builders.
	TblUser *TblUserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.TblAuthClient = NewTblAuthClientClient(c.config)
	c.TblAuthToken = NewTblAuthTokenClient(c.config)
	c.TblCart = NewTblCartClient(c.config)
	c.TblInventory = NewTblInventoryClient(c.config)
	c.TblInventoryTag = NewTblInventoryTagClient(c.config)
	c.TblPayment = NewTblPaymentClient(c.config)
	c.TblTag = NewTblTagClient(c.config)
	c.TblUser = NewTblUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("entgen: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("entgen: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		TblAuthClient:   NewTblAuthClientClient(cfg),
		TblAuthToken:    NewTblAuthTokenClient(cfg),
		TblCart:         NewTblCartClient(cfg),
		TblInventory:    NewTblInventoryClient(cfg),
		TblInventoryTag: NewTblInventoryTagClient(cfg),
		TblPayment:      NewTblPaymentClient(cfg),
		TblTag:          NewTblTagClient(cfg),
		TblUser:         NewTblUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		TblAuthClient:   NewTblAuthClientClient(cfg),
		TblAuthToken:    NewTblAuthTokenClient(cfg),
		TblCart:         NewTblCartClient(cfg),
		TblInventory:    NewTblInventoryClient(cfg),
		TblInventoryTag: NewTblInventoryTagClient(cfg),
		TblPayment:      NewTblPaymentClient(cfg),
		TblTag:          NewTblTagClient(cfg),
		TblUser:         NewTblUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		TblAuthClient.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.TblAuthClient, c.TblAuthToken, c.TblCart, c.TblInventory, c.TblInventoryTag,
		c.TblPayment, c.TblTag, c.TblUser,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.TblAuthClient, c.TblAuthToken, c.TblCart, c.TblInventory, c.TblInventoryTag,
		c.TblPayment, c.TblTag, c.TblUser,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *TblAuthClientMutation:
		return c.TblAuthClient.mutate(ctx, m)
	case *TblAuthTokenMutation:
		return c.TblAuthToken.mutate(ctx, m)
	case *TblCartMutation:
		return c.TblCart.mutate(ctx, m)
	case *TblInventoryMutation:
		return c.TblInventory.mutate(ctx, m)
	case *TblInventoryTagMutation:
		return c.TblInventoryTag.mutate(ctx, m)
	case *TblPaymentMutation:
		return c.TblPayment.mutate(ctx, m)
	case *TblTagMutation:
		return c.TblTag.mutate(ctx, m)
	case *TblUserMutation:
		return c.TblUser.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("entgen: unknown mutation type %T", m)
	}
}

// TblAuthClientClient is a client for the TblAuthClient schema.
type TblAuthClientClient struct {
	config
}

// NewTblAuthClientClient returns a client for the TblAuthClient from the given config.
func NewTblAuthClientClient(c config) *TblAuthClientClient {
	return &TblAuthClientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblauthclient.Hooks(f(g(h())))`.
func (c *TblAuthClientClient) Use(hooks ...Hook) {
	c.hooks.TblAuthClient = append(c.hooks.TblAuthClient, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblauthclient.Intercept(f(g(h())))`.
func (c *TblAuthClientClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblAuthClient = append(c.inters.TblAuthClient, interceptors...)
}

// Create returns a builder for creating a TblAuthClient entity.
func (c *TblAuthClientClient) Create() *TblAuthClientCreate {
	mutation := newTblAuthClientMutation(c.config, OpCreate)
	return &TblAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblAuthClient entities.
func (c *TblAuthClientClient) CreateBulk(builders ...*TblAuthClientCreate) *TblAuthClientCreateBulk {
	return &TblAuthClientCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblAuthClientClient) MapCreateBulk(slice any, setFunc func(*TblAuthClientCreate, int)) *TblAuthClientCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblAuthClientCreateBulk{err: fmt.Errorf("calling to TblAuthClientClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblAuthClientCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblAuthClientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblAuthClient.
func (c *TblAuthClientClient) Update() *TblAuthClientUpdate {
	mutation := newTblAuthClientMutation(c.config, OpUpdate)
	return &TblAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblAuthClientClient) UpdateOne(tac *TblAuthClient) *TblAuthClientUpdateOne {
	mutation := newTblAuthClientMutation(c.config, OpUpdateOne, withTblAuthClient(tac))
	return &TblAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblAuthClientClient) UpdateOneID(id string) *TblAuthClientUpdateOne {
	mutation := newTblAuthClientMutation(c.config, OpUpdateOne, withTblAuthClientID(id))
	return &TblAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblAuthClient.
func (c *TblAuthClientClient) Delete() *TblAuthClientDelete {
	mutation := newTblAuthClientMutation(c.config, OpDelete)
	return &TblAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblAuthClientClient) DeleteOne(tac *TblAuthClient) *TblAuthClientDeleteOne {
	return c.DeleteOneID(tac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblAuthClientClient) DeleteOneID(id string) *TblAuthClientDeleteOne {
	builder := c.Delete().Where(tblauthclient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblAuthClientDeleteOne{builder}
}

// Query returns a query builder for TblAuthClient.
func (c *TblAuthClientClient) Query() *TblAuthClientQuery {
	return &TblAuthClientQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblAuthClient},
		inters: c.Interceptors(),
	}
}

// Get returns a TblAuthClient entity by its id.
func (c *TblAuthClientClient) Get(ctx context.Context, id string) (*TblAuthClient, error) {
	return c.Query().Where(tblauthclient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblAuthClientClient) GetX(ctx context.Context, id string) *TblAuthClient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClientToken queries the ClientToken edge of a TblAuthClient.
func (c *TblAuthClientClient) QueryClientToken(tac *TblAuthClient) *TblAuthTokenQuery {
	query := (&TblAuthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblauthclient.Table, tblauthclient.FieldID, id),
			sqlgraph.To(tblauthtoken.Table, tblauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tblauthclient.ClientTokenTable, tblauthclient.ClientTokenColumn),
		)
		fromV = sqlgraph.Neighbors(tac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblAuthClientClient) Hooks() []Hook {
	return c.hooks.TblAuthClient
}

// Interceptors returns the client interceptors.
func (c *TblAuthClientClient) Interceptors() []Interceptor {
	return c.inters.TblAuthClient
}

func (c *TblAuthClientClient) mutate(ctx context.Context, m *TblAuthClientMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblAuthClientCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblAuthClientUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblAuthClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblAuthClientDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblAuthClient mutation op: %q", m.Op())
	}
}

// TblAuthTokenClient is a client for the TblAuthToken schema.
type TblAuthTokenClient struct {
	config
}

// NewTblAuthTokenClient returns a client for the TblAuthToken from the given config.
func NewTblAuthTokenClient(c config) *TblAuthTokenClient {
	return &TblAuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblauthtoken.Hooks(f(g(h())))`.
func (c *TblAuthTokenClient) Use(hooks ...Hook) {
	c.hooks.TblAuthToken = append(c.hooks.TblAuthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblauthtoken.Intercept(f(g(h())))`.
func (c *TblAuthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblAuthToken = append(c.inters.TblAuthToken, interceptors...)
}

// Create returns a builder for creating a TblAuthToken entity.
func (c *TblAuthTokenClient) Create() *TblAuthTokenCreate {
	mutation := newTblAuthTokenMutation(c.config, OpCreate)
	return &TblAuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblAuthToken entities.
func (c *TblAuthTokenClient) CreateBulk(builders ...*TblAuthTokenCreate) *TblAuthTokenCreateBulk {
	return &TblAuthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblAuthTokenClient) MapCreateBulk(slice any, setFunc func(*TblAuthTokenCreate, int)) *TblAuthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblAuthTokenCreateBulk{err: fmt.Errorf("calling to TblAuthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblAuthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblAuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblAuthToken.
func (c *TblAuthTokenClient) Update() *TblAuthTokenUpdate {
	mutation := newTblAuthTokenMutation(c.config, OpUpdate)
	return &TblAuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblAuthTokenClient) UpdateOne(tat *TblAuthToken) *TblAuthTokenUpdateOne {
	mutation := newTblAuthTokenMutation(c.config, OpUpdateOne, withTblAuthToken(tat))
	return &TblAuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblAuthTokenClient) UpdateOneID(id string) *TblAuthTokenUpdateOne {
	mutation := newTblAuthTokenMutation(c.config, OpUpdateOne, withTblAuthTokenID(id))
	return &TblAuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblAuthToken.
func (c *TblAuthTokenClient) Delete() *TblAuthTokenDelete {
	mutation := newTblAuthTokenMutation(c.config, OpDelete)
	return &TblAuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblAuthTokenClient) DeleteOne(tat *TblAuthToken) *TblAuthTokenDeleteOne {
	return c.DeleteOneID(tat.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblAuthTokenClient) DeleteOneID(id string) *TblAuthTokenDeleteOne {
	builder := c.Delete().Where(tblauthtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblAuthTokenDeleteOne{builder}
}

// Query returns a query builder for TblAuthToken.
func (c *TblAuthTokenClient) Query() *TblAuthTokenQuery {
	return &TblAuthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblAuthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a TblAuthToken entity by its id.
func (c *TblAuthTokenClient) Get(ctx context.Context, id string) (*TblAuthToken, error) {
	return c.Query().Where(tblauthtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblAuthTokenClient) GetX(ctx context.Context, id string) *TblAuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTokenClient queries the TokenClient edge of a TblAuthToken.
func (c *TblAuthTokenClient) QueryTokenClient(tat *TblAuthToken) *TblAuthClientQuery {
	query := (&TblAuthClientClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblauthtoken.Table, tblauthtoken.FieldID, id),
			sqlgraph.To(tblauthclient.Table, tblauthclient.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblauthtoken.TokenClientTable, tblauthtoken.TokenClientColumn),
		)
		fromV = sqlgraph.Neighbors(tat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTokenUser queries the TokenUser edge of a TblAuthToken.
func (c *TblAuthTokenClient) QueryTokenUser(tat *TblAuthToken) *TblUserQuery {
	query := (&TblUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tat.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblauthtoken.Table, tblauthtoken.FieldID, id),
			sqlgraph.To(tbluser.Table, tbluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblauthtoken.TokenUserTable, tblauthtoken.TokenUserColumn),
		)
		fromV = sqlgraph.Neighbors(tat.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblAuthTokenClient) Hooks() []Hook {
	return c.hooks.TblAuthToken
}

// Interceptors returns the client interceptors.
func (c *TblAuthTokenClient) Interceptors() []Interceptor {
	return c.inters.TblAuthToken
}

func (c *TblAuthTokenClient) mutate(ctx context.Context, m *TblAuthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblAuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblAuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblAuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblAuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblAuthToken mutation op: %q", m.Op())
	}
}

// TblCartClient is a client for the TblCart schema.
type TblCartClient struct {
	config
}

// NewTblCartClient returns a client for the TblCart from the given config.
func NewTblCartClient(c config) *TblCartClient {
	return &TblCartClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblcart.Hooks(f(g(h())))`.
func (c *TblCartClient) Use(hooks ...Hook) {
	c.hooks.TblCart = append(c.hooks.TblCart, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblcart.Intercept(f(g(h())))`.
func (c *TblCartClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblCart = append(c.inters.TblCart, interceptors...)
}

// Create returns a builder for creating a TblCart entity.
func (c *TblCartClient) Create() *TblCartCreate {
	mutation := newTblCartMutation(c.config, OpCreate)
	return &TblCartCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblCart entities.
func (c *TblCartClient) CreateBulk(builders ...*TblCartCreate) *TblCartCreateBulk {
	return &TblCartCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblCartClient) MapCreateBulk(slice any, setFunc func(*TblCartCreate, int)) *TblCartCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblCartCreateBulk{err: fmt.Errorf("calling to TblCartClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblCartCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblCartCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblCart.
func (c *TblCartClient) Update() *TblCartUpdate {
	mutation := newTblCartMutation(c.config, OpUpdate)
	return &TblCartUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblCartClient) UpdateOne(tc *TblCart) *TblCartUpdateOne {
	mutation := newTblCartMutation(c.config, OpUpdateOne, withTblCart(tc))
	return &TblCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblCartClient) UpdateOneID(id string) *TblCartUpdateOne {
	mutation := newTblCartMutation(c.config, OpUpdateOne, withTblCartID(id))
	return &TblCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblCart.
func (c *TblCartClient) Delete() *TblCartDelete {
	mutation := newTblCartMutation(c.config, OpDelete)
	return &TblCartDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblCartClient) DeleteOne(tc *TblCart) *TblCartDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblCartClient) DeleteOneID(id string) *TblCartDeleteOne {
	builder := c.Delete().Where(tblcart.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblCartDeleteOne{builder}
}

// Query returns a query builder for TblCart.
func (c *TblCartClient) Query() *TblCartQuery {
	return &TblCartQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblCart},
		inters: c.Interceptors(),
	}
}

// Get returns a TblCart entity by its id.
func (c *TblCartClient) Get(ctx context.Context, id string) (*TblCart, error) {
	return c.Query().Where(tblcart.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblCartClient) GetX(ctx context.Context, id string) *TblCart {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventory queries the Inventory edge of a TblCart.
func (c *TblCartClient) QueryInventory(tc *TblCart) *TblInventoryQuery {
	query := (&TblInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblcart.Table, tblcart.FieldID, id),
			sqlgraph.To(tblinventory.Table, tblinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblcart.InventoryTable, tblcart.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the User edge of a TblCart.
func (c *TblCartClient) QueryUser(tc *TblCart) *TblUserQuery {
	query := (&TblUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblcart.Table, tblcart.FieldID, id),
			sqlgraph.To(tbluser.Table, tbluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblcart.UserTable, tblcart.UserColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblCartClient) Hooks() []Hook {
	return c.hooks.TblCart
}

// Interceptors returns the client interceptors.
func (c *TblCartClient) Interceptors() []Interceptor {
	return c.inters.TblCart
}

func (c *TblCartClient) mutate(ctx context.Context, m *TblCartMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblCartCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblCartUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblCartUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblCartDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblCart mutation op: %q", m.Op())
	}
}

// TblInventoryClient is a client for the TblInventory schema.
type TblInventoryClient struct {
	config
}

// NewTblInventoryClient returns a client for the TblInventory from the given config.
func NewTblInventoryClient(c config) *TblInventoryClient {
	return &TblInventoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblinventory.Hooks(f(g(h())))`.
func (c *TblInventoryClient) Use(hooks ...Hook) {
	c.hooks.TblInventory = append(c.hooks.TblInventory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblinventory.Intercept(f(g(h())))`.
func (c *TblInventoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblInventory = append(c.inters.TblInventory, interceptors...)
}

// Create returns a builder for creating a TblInventory entity.
func (c *TblInventoryClient) Create() *TblInventoryCreate {
	mutation := newTblInventoryMutation(c.config, OpCreate)
	return &TblInventoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblInventory entities.
func (c *TblInventoryClient) CreateBulk(builders ...*TblInventoryCreate) *TblInventoryCreateBulk {
	return &TblInventoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblInventoryClient) MapCreateBulk(slice any, setFunc func(*TblInventoryCreate, int)) *TblInventoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblInventoryCreateBulk{err: fmt.Errorf("calling to TblInventoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblInventoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblInventoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblInventory.
func (c *TblInventoryClient) Update() *TblInventoryUpdate {
	mutation := newTblInventoryMutation(c.config, OpUpdate)
	return &TblInventoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblInventoryClient) UpdateOne(ti *TblInventory) *TblInventoryUpdateOne {
	mutation := newTblInventoryMutation(c.config, OpUpdateOne, withTblInventory(ti))
	return &TblInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblInventoryClient) UpdateOneID(id string) *TblInventoryUpdateOne {
	mutation := newTblInventoryMutation(c.config, OpUpdateOne, withTblInventoryID(id))
	return &TblInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblInventory.
func (c *TblInventoryClient) Delete() *TblInventoryDelete {
	mutation := newTblInventoryMutation(c.config, OpDelete)
	return &TblInventoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblInventoryClient) DeleteOne(ti *TblInventory) *TblInventoryDeleteOne {
	return c.DeleteOneID(ti.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblInventoryClient) DeleteOneID(id string) *TblInventoryDeleteOne {
	builder := c.Delete().Where(tblinventory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblInventoryDeleteOne{builder}
}

// Query returns a query builder for TblInventory.
func (c *TblInventoryClient) Query() *TblInventoryQuery {
	return &TblInventoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblInventory},
		inters: c.Interceptors(),
	}
}

// Get returns a TblInventory entity by its id.
func (c *TblInventoryClient) Get(ctx context.Context, id string) (*TblInventory, error) {
	return c.Query().Where(tblinventory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblInventoryClient) GetX(ctx context.Context, id string) *TblInventory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventoryTag queries the inventoryTag edge of a TblInventory.
func (c *TblInventoryClient) QueryInventoryTag(ti *TblInventory) *TblInventoryTagQuery {
	query := (&TblInventoryTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblinventory.Table, tblinventory.FieldID, id),
			sqlgraph.To(tblinventorytag.Table, tblinventorytag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tblinventory.InventoryTagTable, tblinventory.InventoryTagColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventoryCart queries the InventoryCart edge of a TblInventory.
func (c *TblInventoryClient) QueryInventoryCart(ti *TblInventory) *TblCartQuery {
	query := (&TblCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblinventory.Table, tblinventory.FieldID, id),
			sqlgraph.To(tblcart.Table, tblcart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tblinventory.InventoryCartTable, tblinventory.InventoryCartColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInventoryPayment queries the InventoryPayment edge of a TblInventory.
func (c *TblInventoryClient) QueryInventoryPayment(ti *TblInventory) *TblPaymentQuery {
	query := (&TblPaymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ti.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblinventory.Table, tblinventory.FieldID, id),
			sqlgraph.To(tblpayment.Table, tblpayment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tblinventory.InventoryPaymentTable, tblinventory.InventoryPaymentColumn),
		)
		fromV = sqlgraph.Neighbors(ti.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblInventoryClient) Hooks() []Hook {
	return c.hooks.TblInventory
}

// Interceptors returns the client interceptors.
func (c *TblInventoryClient) Interceptors() []Interceptor {
	return c.inters.TblInventory
}

func (c *TblInventoryClient) mutate(ctx context.Context, m *TblInventoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblInventoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblInventoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblInventoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblInventoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblInventory mutation op: %q", m.Op())
	}
}

// TblInventoryTagClient is a client for the TblInventoryTag schema.
type TblInventoryTagClient struct {
	config
}

// NewTblInventoryTagClient returns a client for the TblInventoryTag from the given config.
func NewTblInventoryTagClient(c config) *TblInventoryTagClient {
	return &TblInventoryTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblinventorytag.Hooks(f(g(h())))`.
func (c *TblInventoryTagClient) Use(hooks ...Hook) {
	c.hooks.TblInventoryTag = append(c.hooks.TblInventoryTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblinventorytag.Intercept(f(g(h())))`.
func (c *TblInventoryTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblInventoryTag = append(c.inters.TblInventoryTag, interceptors...)
}

// Create returns a builder for creating a TblInventoryTag entity.
func (c *TblInventoryTagClient) Create() *TblInventoryTagCreate {
	mutation := newTblInventoryTagMutation(c.config, OpCreate)
	return &TblInventoryTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblInventoryTag entities.
func (c *TblInventoryTagClient) CreateBulk(builders ...*TblInventoryTagCreate) *TblInventoryTagCreateBulk {
	return &TblInventoryTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblInventoryTagClient) MapCreateBulk(slice any, setFunc func(*TblInventoryTagCreate, int)) *TblInventoryTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblInventoryTagCreateBulk{err: fmt.Errorf("calling to TblInventoryTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblInventoryTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblInventoryTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblInventoryTag.
func (c *TblInventoryTagClient) Update() *TblInventoryTagUpdate {
	mutation := newTblInventoryTagMutation(c.config, OpUpdate)
	return &TblInventoryTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblInventoryTagClient) UpdateOne(tit *TblInventoryTag) *TblInventoryTagUpdateOne {
	mutation := newTblInventoryTagMutation(c.config, OpUpdateOne, withTblInventoryTag(tit))
	return &TblInventoryTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblInventoryTagClient) UpdateOneID(id string) *TblInventoryTagUpdateOne {
	mutation := newTblInventoryTagMutation(c.config, OpUpdateOne, withTblInventoryTagID(id))
	return &TblInventoryTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblInventoryTag.
func (c *TblInventoryTagClient) Delete() *TblInventoryTagDelete {
	mutation := newTblInventoryTagMutation(c.config, OpDelete)
	return &TblInventoryTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblInventoryTagClient) DeleteOne(tit *TblInventoryTag) *TblInventoryTagDeleteOne {
	return c.DeleteOneID(tit.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblInventoryTagClient) DeleteOneID(id string) *TblInventoryTagDeleteOne {
	builder := c.Delete().Where(tblinventorytag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblInventoryTagDeleteOne{builder}
}

// Query returns a query builder for TblInventoryTag.
func (c *TblInventoryTagClient) Query() *TblInventoryTagQuery {
	return &TblInventoryTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblInventoryTag},
		inters: c.Interceptors(),
	}
}

// Get returns a TblInventoryTag entity by its id.
func (c *TblInventoryTagClient) Get(ctx context.Context, id string) (*TblInventoryTag, error) {
	return c.Query().Where(tblinventorytag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblInventoryTagClient) GetX(ctx context.Context, id string) *TblInventoryTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventory queries the inventory edge of a TblInventoryTag.
func (c *TblInventoryTagClient) QueryInventory(tit *TblInventoryTag) *TblInventoryQuery {
	query := (&TblInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tit.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblinventorytag.Table, tblinventorytag.FieldID, id),
			sqlgraph.To(tblinventory.Table, tblinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblinventorytag.InventoryTable, tblinventorytag.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(tit.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTag queries the tag edge of a TblInventoryTag.
func (c *TblInventoryTagClient) QueryTag(tit *TblInventoryTag) *TblTagQuery {
	query := (&TblTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tit.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblinventorytag.Table, tblinventorytag.FieldID, id),
			sqlgraph.To(tbltag.Table, tbltag.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblinventorytag.TagTable, tblinventorytag.TagColumn),
		)
		fromV = sqlgraph.Neighbors(tit.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblInventoryTagClient) Hooks() []Hook {
	return c.hooks.TblInventoryTag
}

// Interceptors returns the client interceptors.
func (c *TblInventoryTagClient) Interceptors() []Interceptor {
	return c.inters.TblInventoryTag
}

func (c *TblInventoryTagClient) mutate(ctx context.Context, m *TblInventoryTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblInventoryTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblInventoryTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblInventoryTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblInventoryTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblInventoryTag mutation op: %q", m.Op())
	}
}

// TblPaymentClient is a client for the TblPayment schema.
type TblPaymentClient struct {
	config
}

// NewTblPaymentClient returns a client for the TblPayment from the given config.
func NewTblPaymentClient(c config) *TblPaymentClient {
	return &TblPaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tblpayment.Hooks(f(g(h())))`.
func (c *TblPaymentClient) Use(hooks ...Hook) {
	c.hooks.TblPayment = append(c.hooks.TblPayment, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tblpayment.Intercept(f(g(h())))`.
func (c *TblPaymentClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblPayment = append(c.inters.TblPayment, interceptors...)
}

// Create returns a builder for creating a TblPayment entity.
func (c *TblPaymentClient) Create() *TblPaymentCreate {
	mutation := newTblPaymentMutation(c.config, OpCreate)
	return &TblPaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblPayment entities.
func (c *TblPaymentClient) CreateBulk(builders ...*TblPaymentCreate) *TblPaymentCreateBulk {
	return &TblPaymentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblPaymentClient) MapCreateBulk(slice any, setFunc func(*TblPaymentCreate, int)) *TblPaymentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblPaymentCreateBulk{err: fmt.Errorf("calling to TblPaymentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblPaymentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblPaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblPayment.
func (c *TblPaymentClient) Update() *TblPaymentUpdate {
	mutation := newTblPaymentMutation(c.config, OpUpdate)
	return &TblPaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblPaymentClient) UpdateOne(tp *TblPayment) *TblPaymentUpdateOne {
	mutation := newTblPaymentMutation(c.config, OpUpdateOne, withTblPayment(tp))
	return &TblPaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblPaymentClient) UpdateOneID(id string) *TblPaymentUpdateOne {
	mutation := newTblPaymentMutation(c.config, OpUpdateOne, withTblPaymentID(id))
	return &TblPaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblPayment.
func (c *TblPaymentClient) Delete() *TblPaymentDelete {
	mutation := newTblPaymentMutation(c.config, OpDelete)
	return &TblPaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblPaymentClient) DeleteOne(tp *TblPayment) *TblPaymentDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblPaymentClient) DeleteOneID(id string) *TblPaymentDeleteOne {
	builder := c.Delete().Where(tblpayment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblPaymentDeleteOne{builder}
}

// Query returns a query builder for TblPayment.
func (c *TblPaymentClient) Query() *TblPaymentQuery {
	return &TblPaymentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblPayment},
		inters: c.Interceptors(),
	}
}

// Get returns a TblPayment entity by its id.
func (c *TblPaymentClient) Get(ctx context.Context, id string) (*TblPayment, error) {
	return c.Query().Where(tblpayment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblPaymentClient) GetX(ctx context.Context, id string) *TblPayment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventory queries the Inventory edge of a TblPayment.
func (c *TblPaymentClient) QueryInventory(tp *TblPayment) *TblInventoryQuery {
	query := (&TblInventoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblpayment.Table, tblpayment.FieldID, id),
			sqlgraph.To(tblinventory.Table, tblinventory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblpayment.InventoryTable, tblpayment.InventoryColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the User edge of a TblPayment.
func (c *TblPaymentClient) QueryUser(tp *TblPayment) *TblUserQuery {
	query := (&TblUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tblpayment.Table, tblpayment.FieldID, id),
			sqlgraph.To(tbluser.Table, tbluser.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tblpayment.UserTable, tblpayment.UserColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblPaymentClient) Hooks() []Hook {
	return c.hooks.TblPayment
}

// Interceptors returns the client interceptors.
func (c *TblPaymentClient) Interceptors() []Interceptor {
	return c.inters.TblPayment
}

func (c *TblPaymentClient) mutate(ctx context.Context, m *TblPaymentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblPaymentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblPaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblPaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblPaymentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblPayment mutation op: %q", m.Op())
	}
}

// TblTagClient is a client for the TblTag schema.
type TblTagClient struct {
	config
}

// NewTblTagClient returns a client for the TblTag from the given config.
func NewTblTagClient(c config) *TblTagClient {
	return &TblTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tbltag.Hooks(f(g(h())))`.
func (c *TblTagClient) Use(hooks ...Hook) {
	c.hooks.TblTag = append(c.hooks.TblTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tbltag.Intercept(f(g(h())))`.
func (c *TblTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblTag = append(c.inters.TblTag, interceptors...)
}

// Create returns a builder for creating a TblTag entity.
func (c *TblTagClient) Create() *TblTagCreate {
	mutation := newTblTagMutation(c.config, OpCreate)
	return &TblTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblTag entities.
func (c *TblTagClient) CreateBulk(builders ...*TblTagCreate) *TblTagCreateBulk {
	return &TblTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblTagClient) MapCreateBulk(slice any, setFunc func(*TblTagCreate, int)) *TblTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblTagCreateBulk{err: fmt.Errorf("calling to TblTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblTag.
func (c *TblTagClient) Update() *TblTagUpdate {
	mutation := newTblTagMutation(c.config, OpUpdate)
	return &TblTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblTagClient) UpdateOne(tt *TblTag) *TblTagUpdateOne {
	mutation := newTblTagMutation(c.config, OpUpdateOne, withTblTag(tt))
	return &TblTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblTagClient) UpdateOneID(id string) *TblTagUpdateOne {
	mutation := newTblTagMutation(c.config, OpUpdateOne, withTblTagID(id))
	return &TblTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblTag.
func (c *TblTagClient) Delete() *TblTagDelete {
	mutation := newTblTagMutation(c.config, OpDelete)
	return &TblTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblTagClient) DeleteOne(tt *TblTag) *TblTagDeleteOne {
	return c.DeleteOneID(tt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblTagClient) DeleteOneID(id string) *TblTagDeleteOne {
	builder := c.Delete().Where(tbltag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblTagDeleteOne{builder}
}

// Query returns a query builder for TblTag.
func (c *TblTagClient) Query() *TblTagQuery {
	return &TblTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblTag},
		inters: c.Interceptors(),
	}
}

// Get returns a TblTag entity by its id.
func (c *TblTagClient) Get(ctx context.Context, id string) (*TblTag, error) {
	return c.Query().Where(tbltag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblTagClient) GetX(ctx context.Context, id string) *TblTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInventoryTag queries the inventoryTag edge of a TblTag.
func (c *TblTagClient) QueryInventoryTag(tt *TblTag) *TblInventoryTagQuery {
	query := (&TblInventoryTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tbltag.Table, tbltag.FieldID, id),
			sqlgraph.To(tblinventorytag.Table, tblinventorytag.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tbltag.InventoryTagTable, tbltag.InventoryTagColumn),
		)
		fromV = sqlgraph.Neighbors(tt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblTagClient) Hooks() []Hook {
	return c.hooks.TblTag
}

// Interceptors returns the client interceptors.
func (c *TblTagClient) Interceptors() []Interceptor {
	return c.inters.TblTag
}

func (c *TblTagClient) mutate(ctx context.Context, m *TblTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblTag mutation op: %q", m.Op())
	}
}

// TblUserClient is a client for the TblUser schema.
type TblUserClient struct {
	config
}

// NewTblUserClient returns a client for the TblUser from the given config.
func NewTblUserClient(c config) *TblUserClient {
	return &TblUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tbluser.Hooks(f(g(h())))`.
func (c *TblUserClient) Use(hooks ...Hook) {
	c.hooks.TblUser = append(c.hooks.TblUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tbluser.Intercept(f(g(h())))`.
func (c *TblUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.TblUser = append(c.inters.TblUser, interceptors...)
}

// Create returns a builder for creating a TblUser entity.
func (c *TblUserClient) Create() *TblUserCreate {
	mutation := newTblUserMutation(c.config, OpCreate)
	return &TblUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TblUser entities.
func (c *TblUserClient) CreateBulk(builders ...*TblUserCreate) *TblUserCreateBulk {
	return &TblUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TblUserClient) MapCreateBulk(slice any, setFunc func(*TblUserCreate, int)) *TblUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TblUserCreateBulk{err: fmt.Errorf("calling to TblUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TblUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TblUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TblUser.
func (c *TblUserClient) Update() *TblUserUpdate {
	mutation := newTblUserMutation(c.config, OpUpdate)
	return &TblUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TblUserClient) UpdateOne(tu *TblUser) *TblUserUpdateOne {
	mutation := newTblUserMutation(c.config, OpUpdateOne, withTblUser(tu))
	return &TblUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TblUserClient) UpdateOneID(id string) *TblUserUpdateOne {
	mutation := newTblUserMutation(c.config, OpUpdateOne, withTblUserID(id))
	return &TblUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TblUser.
func (c *TblUserClient) Delete() *TblUserDelete {
	mutation := newTblUserMutation(c.config, OpDelete)
	return &TblUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TblUserClient) DeleteOne(tu *TblUser) *TblUserDeleteOne {
	return c.DeleteOneID(tu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TblUserClient) DeleteOneID(id string) *TblUserDeleteOne {
	builder := c.Delete().Where(tbluser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TblUserDeleteOne{builder}
}

// Query returns a query builder for TblUser.
func (c *TblUserClient) Query() *TblUserQuery {
	return &TblUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTblUser},
		inters: c.Interceptors(),
	}
}

// Get returns a TblUser entity by its id.
func (c *TblUserClient) Get(ctx context.Context, id string) (*TblUser, error) {
	return c.Query().Where(tbluser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TblUserClient) GetX(ctx context.Context, id string) *TblUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserToken queries the UserToken edge of a TblUser.
func (c *TblUserClient) QueryUserToken(tu *TblUser) *TblAuthTokenQuery {
	query := (&TblAuthTokenClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tbluser.Table, tbluser.FieldID, id),
			sqlgraph.To(tblauthtoken.Table, tblauthtoken.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tbluser.UserTokenTable, tbluser.UserTokenColumn),
		)
		fromV = sqlgraph.Neighbors(tu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserCart queries the UserCart edge of a TblUser.
func (c *TblUserClient) QueryUserCart(tu *TblUser) *TblCartQuery {
	query := (&TblCartClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tbluser.Table, tbluser.FieldID, id),
			sqlgraph.To(tblcart.Table, tblcart.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tbluser.UserCartTable, tbluser.UserCartColumn),
		)
		fromV = sqlgraph.Neighbors(tu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserPayment queries the UserPayment edge of a TblUser.
func (c *TblUserClient) QueryUserPayment(tu *TblUser) *TblPaymentQuery {
	query := (&TblPaymentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tbluser.Table, tbluser.FieldID, id),
			sqlgraph.To(tblpayment.Table, tblpayment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tbluser.UserPaymentTable, tbluser.UserPaymentColumn),
		)
		fromV = sqlgraph.Neighbors(tu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TblUserClient) Hooks() []Hook {
	return c.hooks.TblUser
}

// Interceptors returns the client interceptors.
func (c *TblUserClient) Interceptors() []Interceptor {
	return c.inters.TblUser
}

func (c *TblUserClient) mutate(ctx context.Context, m *TblUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TblUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TblUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TblUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TblUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("entgen: unknown TblUser mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		TblAuthClient, TblAuthToken, TblCart, TblInventory, TblInventoryTag, TblPayment,
		TblTag, TblUser []ent.Hook
	}
	inters struct {
		TblAuthClient, TblAuthToken, TblCart, TblInventory, TblInventoryTag, TblPayment,
		TblTag, TblUser []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
