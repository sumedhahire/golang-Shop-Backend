// Code generated by ent, DO NOT EDIT.

package entgen

import (
	"context"
	"errors"
	"fmt"
	"inventory/ent/entgen/predicate"
	"inventory/ent/entgen/tblauthclient"
	"inventory/ent/entgen/tblauthtoken"
	"inventory/ent/entgen/tblcart"
	"inventory/ent/entgen/tblinventory"
	"inventory/ent/entgen/tblinventorytag"
	"inventory/ent/entgen/tblpayment"
	"inventory/ent/entgen/tbltag"
	"inventory/ent/entgen/tbluser"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeTblAuthClient   = "TblAuthClient"
	TypeTblAuthToken    = "TblAuthToken"
	TypeTblCart         = "TblCart"
	TypeTblInventory    = "TblInventory"
	TypeTblInventoryTag = "TblInventoryTag"
	TypeTblPayment      = "TblPayment"
	TypeTblTag          = "TblTag"
	TypeTblUser         = "TblUser"
)

// TblAuthClientMutation represents an operation that mutates the TblAuthClient nodes in the graph.
type TblAuthClientMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	_Client_secret      *string
	_Grant_type         *string
	_CreatedAt          *time.Time
	_UpdatedAt          *time.Time
	_DeletedAt          *time.Time
	domain              *string
	public              *bool
	_UserAgent          *string
	redirect_uri        *string
	_CreatedBy          *string
	_UpdatedBy          *string
	_DeletedBy          *string
	clearedFields       map[string]struct{}
	_ClientToken        map[string]struct{}
	removed_ClientToken map[string]struct{}
	cleared_ClientToken bool
	done                bool
	oldValue            func(context.Context) (*TblAuthClient, error)
	predicates          []predicate.TblAuthClient
}

var _ ent.Mutation = (*TblAuthClientMutation)(nil)

// tblauthclientOption allows management of the mutation configuration using functional options.
type tblauthclientOption func(*TblAuthClientMutation)

// newTblAuthClientMutation creates new mutation for the TblAuthClient entity.
func newTblAuthClientMutation(c config, op Op, opts ...tblauthclientOption) *TblAuthClientMutation {
	m := &TblAuthClientMutation{
		config:        c,
		op:            op,
		typ:           TypeTblAuthClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblAuthClientID sets the ID field of the mutation.
func withTblAuthClientID(id string) tblauthclientOption {
	return func(m *TblAuthClientMutation) {
		var (
			err   error
			once  sync.Once
			value *TblAuthClient
		)
		m.oldValue = func(ctx context.Context) (*TblAuthClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblAuthClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblAuthClient sets the old TblAuthClient of the mutation.
func withTblAuthClient(node *TblAuthClient) tblauthclientOption {
	return func(m *TblAuthClientMutation) {
		m.oldValue = func(context.Context) (*TblAuthClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblAuthClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblAuthClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblAuthClient entities.
func (m *TblAuthClientMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblAuthClientMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblAuthClientMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblAuthClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientSecret sets the "Client_secret" field.
func (m *TblAuthClientMutation) SetClientSecret(s string) {
	m._Client_secret = &s
}

// ClientSecret returns the value of the "Client_secret" field in the mutation.
func (m *TblAuthClientMutation) ClientSecret() (r string, exists bool) {
	v := m._Client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "Client_secret" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "Client_secret" field.
func (m *TblAuthClientMutation) ResetClientSecret() {
	m._Client_secret = nil
}

// SetGrantType sets the "Grant_type" field.
func (m *TblAuthClientMutation) SetGrantType(s string) {
	m._Grant_type = &s
}

// GrantType returns the value of the "Grant_type" field in the mutation.
func (m *TblAuthClientMutation) GrantType() (r string, exists bool) {
	v := m._Grant_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantType returns the old "Grant_type" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldGrantType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantType: %w", err)
	}
	return oldValue.GrantType, nil
}

// ClearGrantType clears the value of the "Grant_type" field.
func (m *TblAuthClientMutation) ClearGrantType() {
	m._Grant_type = nil
	m.clearedFields[tblauthclient.FieldGrantType] = struct{}{}
}

// GrantTypeCleared returns if the "Grant_type" field was cleared in this mutation.
func (m *TblAuthClientMutation) GrantTypeCleared() bool {
	_, ok := m.clearedFields[tblauthclient.FieldGrantType]
	return ok
}

// ResetGrantType resets all changes to the "Grant_type" field.
func (m *TblAuthClientMutation) ResetGrantType() {
	m._Grant_type = nil
	delete(m.clearedFields, tblauthclient.FieldGrantType)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *TblAuthClientMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *TblAuthClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *TblAuthClientMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *TblAuthClientMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *TblAuthClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *TblAuthClientMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetDeletedAt sets the "DeletedAt" field.
func (m *TblAuthClientMutation) SetDeletedAt(t time.Time) {
	m._DeletedAt = &t
}

// DeletedAt returns the value of the "DeletedAt" field in the mutation.
func (m *TblAuthClientMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._DeletedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "DeletedAt" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "DeletedAt" field.
func (m *TblAuthClientMutation) ClearDeletedAt() {
	m._DeletedAt = nil
	m.clearedFields[tblauthclient.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "DeletedAt" field was cleared in this mutation.
func (m *TblAuthClientMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tblauthclient.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "DeletedAt" field.
func (m *TblAuthClientMutation) ResetDeletedAt() {
	m._DeletedAt = nil
	delete(m.clearedFields, tblauthclient.FieldDeletedAt)
}

// SetDomain sets the "domain" field.
func (m *TblAuthClientMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *TblAuthClientMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldDomain(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ClearDomain clears the value of the "domain" field.
func (m *TblAuthClientMutation) ClearDomain() {
	m.domain = nil
	m.clearedFields[tblauthclient.FieldDomain] = struct{}{}
}

// DomainCleared returns if the "domain" field was cleared in this mutation.
func (m *TblAuthClientMutation) DomainCleared() bool {
	_, ok := m.clearedFields[tblauthclient.FieldDomain]
	return ok
}

// ResetDomain resets all changes to the "domain" field.
func (m *TblAuthClientMutation) ResetDomain() {
	m.domain = nil
	delete(m.clearedFields, tblauthclient.FieldDomain)
}

// SetPublic sets the "public" field.
func (m *TblAuthClientMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *TblAuthClientMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *TblAuthClientMutation) ResetPublic() {
	m.public = nil
}

// SetUserAgent sets the "UserAgent" field.
func (m *TblAuthClientMutation) SetUserAgent(s string) {
	m._UserAgent = &s
}

// UserAgent returns the value of the "UserAgent" field in the mutation.
func (m *TblAuthClientMutation) UserAgent() (r string, exists bool) {
	v := m._UserAgent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "UserAgent" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ResetUserAgent resets all changes to the "UserAgent" field.
func (m *TblAuthClientMutation) ResetUserAgent() {
	m._UserAgent = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *TblAuthClientMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *TblAuthClientMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldRedirectURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *TblAuthClientMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[tblauthclient.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *TblAuthClientMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[tblauthclient.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *TblAuthClientMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, tblauthclient.FieldRedirectURI)
}

// SetCreatedBy sets the "CreatedBy" field.
func (m *TblAuthClientMutation) SetCreatedBy(s string) {
	m._CreatedBy = &s
}

// CreatedBy returns the value of the "CreatedBy" field in the mutation.
func (m *TblAuthClientMutation) CreatedBy() (r string, exists bool) {
	v := m._CreatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "CreatedBy" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "CreatedBy" field.
func (m *TblAuthClientMutation) ResetCreatedBy() {
	m._CreatedBy = nil
}

// SetUpdatedBy sets the "UpdatedBy" field.
func (m *TblAuthClientMutation) SetUpdatedBy(s string) {
	m._UpdatedBy = &s
}

// UpdatedBy returns the value of the "UpdatedBy" field in the mutation.
func (m *TblAuthClientMutation) UpdatedBy() (r string, exists bool) {
	v := m._UpdatedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "UpdatedBy" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "UpdatedBy" field.
func (m *TblAuthClientMutation) ResetUpdatedBy() {
	m._UpdatedBy = nil
}

// SetDeletedBy sets the "DeletedBy" field.
func (m *TblAuthClientMutation) SetDeletedBy(s string) {
	m._DeletedBy = &s
}

// DeletedBy returns the value of the "DeletedBy" field in the mutation.
func (m *TblAuthClientMutation) DeletedBy() (r string, exists bool) {
	v := m._DeletedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "DeletedBy" field's value of the TblAuthClient entity.
// If the TblAuthClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthClientMutation) OldDeletedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "DeletedBy" field.
func (m *TblAuthClientMutation) ClearDeletedBy() {
	m._DeletedBy = nil
	m.clearedFields[tblauthclient.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "DeletedBy" field was cleared in this mutation.
func (m *TblAuthClientMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tblauthclient.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "DeletedBy" field.
func (m *TblAuthClientMutation) ResetDeletedBy() {
	m._DeletedBy = nil
	delete(m.clearedFields, tblauthclient.FieldDeletedBy)
}

// AddClientTokenIDs adds the "ClientToken" edge to the TblAuthToken entity by ids.
func (m *TblAuthClientMutation) AddClientTokenIDs(ids ...string) {
	if m._ClientToken == nil {
		m._ClientToken = make(map[string]struct{})
	}
	for i := range ids {
		m._ClientToken[ids[i]] = struct{}{}
	}
}

// ClearClientToken clears the "ClientToken" edge to the TblAuthToken entity.
func (m *TblAuthClientMutation) ClearClientToken() {
	m.cleared_ClientToken = true
}

// ClientTokenCleared reports if the "ClientToken" edge to the TblAuthToken entity was cleared.
func (m *TblAuthClientMutation) ClientTokenCleared() bool {
	return m.cleared_ClientToken
}

// RemoveClientTokenIDs removes the "ClientToken" edge to the TblAuthToken entity by IDs.
func (m *TblAuthClientMutation) RemoveClientTokenIDs(ids ...string) {
	if m.removed_ClientToken == nil {
		m.removed_ClientToken = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._ClientToken, ids[i])
		m.removed_ClientToken[ids[i]] = struct{}{}
	}
}

// RemovedClientToken returns the removed IDs of the "ClientToken" edge to the TblAuthToken entity.
func (m *TblAuthClientMutation) RemovedClientTokenIDs() (ids []string) {
	for id := range m.removed_ClientToken {
		ids = append(ids, id)
	}
	return
}

// ClientTokenIDs returns the "ClientToken" edge IDs in the mutation.
func (m *TblAuthClientMutation) ClientTokenIDs() (ids []string) {
	for id := range m._ClientToken {
		ids = append(ids, id)
	}
	return
}

// ResetClientToken resets all changes to the "ClientToken" edge.
func (m *TblAuthClientMutation) ResetClientToken() {
	m._ClientToken = nil
	m.cleared_ClientToken = false
	m.removed_ClientToken = nil
}

// Where appends a list predicates to the TblAuthClientMutation builder.
func (m *TblAuthClientMutation) Where(ps ...predicate.TblAuthClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblAuthClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblAuthClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblAuthClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblAuthClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblAuthClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblAuthClient).
func (m *TblAuthClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblAuthClientMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._Client_secret != nil {
		fields = append(fields, tblauthclient.FieldClientSecret)
	}
	if m._Grant_type != nil {
		fields = append(fields, tblauthclient.FieldGrantType)
	}
	if m._CreatedAt != nil {
		fields = append(fields, tblauthclient.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, tblauthclient.FieldUpdatedAt)
	}
	if m._DeletedAt != nil {
		fields = append(fields, tblauthclient.FieldDeletedAt)
	}
	if m.domain != nil {
		fields = append(fields, tblauthclient.FieldDomain)
	}
	if m.public != nil {
		fields = append(fields, tblauthclient.FieldPublic)
	}
	if m._UserAgent != nil {
		fields = append(fields, tblauthclient.FieldUserAgent)
	}
	if m.redirect_uri != nil {
		fields = append(fields, tblauthclient.FieldRedirectURI)
	}
	if m._CreatedBy != nil {
		fields = append(fields, tblauthclient.FieldCreatedBy)
	}
	if m._UpdatedBy != nil {
		fields = append(fields, tblauthclient.FieldUpdatedBy)
	}
	if m._DeletedBy != nil {
		fields = append(fields, tblauthclient.FieldDeletedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblAuthClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblauthclient.FieldClientSecret:
		return m.ClientSecret()
	case tblauthclient.FieldGrantType:
		return m.GrantType()
	case tblauthclient.FieldCreatedAt:
		return m.CreatedAt()
	case tblauthclient.FieldUpdatedAt:
		return m.UpdatedAt()
	case tblauthclient.FieldDeletedAt:
		return m.DeletedAt()
	case tblauthclient.FieldDomain:
		return m.Domain()
	case tblauthclient.FieldPublic:
		return m.Public()
	case tblauthclient.FieldUserAgent:
		return m.UserAgent()
	case tblauthclient.FieldRedirectURI:
		return m.RedirectURI()
	case tblauthclient.FieldCreatedBy:
		return m.CreatedBy()
	case tblauthclient.FieldUpdatedBy:
		return m.UpdatedBy()
	case tblauthclient.FieldDeletedBy:
		return m.DeletedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblAuthClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblauthclient.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case tblauthclient.FieldGrantType:
		return m.OldGrantType(ctx)
	case tblauthclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tblauthclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tblauthclient.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tblauthclient.FieldDomain:
		return m.OldDomain(ctx)
	case tblauthclient.FieldPublic:
		return m.OldPublic(ctx)
	case tblauthclient.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case tblauthclient.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case tblauthclient.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tblauthclient.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tblauthclient.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	}
	return nil, fmt.Errorf("unknown TblAuthClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblAuthClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblauthclient.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case tblauthclient.FieldGrantType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantType(v)
		return nil
	case tblauthclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tblauthclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tblauthclient.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tblauthclient.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case tblauthclient.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case tblauthclient.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case tblauthclient.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case tblauthclient.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tblauthclient.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tblauthclient.FieldDeletedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown TblAuthClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblAuthClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblAuthClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblAuthClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TblAuthClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblAuthClientMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblauthclient.FieldGrantType) {
		fields = append(fields, tblauthclient.FieldGrantType)
	}
	if m.FieldCleared(tblauthclient.FieldDeletedAt) {
		fields = append(fields, tblauthclient.FieldDeletedAt)
	}
	if m.FieldCleared(tblauthclient.FieldDomain) {
		fields = append(fields, tblauthclient.FieldDomain)
	}
	if m.FieldCleared(tblauthclient.FieldRedirectURI) {
		fields = append(fields, tblauthclient.FieldRedirectURI)
	}
	if m.FieldCleared(tblauthclient.FieldDeletedBy) {
		fields = append(fields, tblauthclient.FieldDeletedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblAuthClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblAuthClientMutation) ClearField(name string) error {
	switch name {
	case tblauthclient.FieldGrantType:
		m.ClearGrantType()
		return nil
	case tblauthclient.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tblauthclient.FieldDomain:
		m.ClearDomain()
		return nil
	case tblauthclient.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	case tblauthclient.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown TblAuthClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblAuthClientMutation) ResetField(name string) error {
	switch name {
	case tblauthclient.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case tblauthclient.FieldGrantType:
		m.ResetGrantType()
		return nil
	case tblauthclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tblauthclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tblauthclient.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tblauthclient.FieldDomain:
		m.ResetDomain()
		return nil
	case tblauthclient.FieldPublic:
		m.ResetPublic()
		return nil
	case tblauthclient.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case tblauthclient.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case tblauthclient.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tblauthclient.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tblauthclient.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	}
	return fmt.Errorf("unknown TblAuthClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblAuthClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ClientToken != nil {
		edges = append(edges, tblauthclient.EdgeClientToken)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblAuthClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblauthclient.EdgeClientToken:
		ids := make([]ent.Value, 0, len(m._ClientToken))
		for id := range m._ClientToken {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblAuthClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_ClientToken != nil {
		edges = append(edges, tblauthclient.EdgeClientToken)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblAuthClientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tblauthclient.EdgeClientToken:
		ids := make([]ent.Value, 0, len(m.removed_ClientToken))
		for id := range m.removed_ClientToken {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblAuthClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ClientToken {
		edges = append(edges, tblauthclient.EdgeClientToken)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblAuthClientMutation) EdgeCleared(name string) bool {
	switch name {
	case tblauthclient.EdgeClientToken:
		return m.cleared_ClientToken
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblAuthClientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TblAuthClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblAuthClientMutation) ResetEdge(name string) error {
	switch name {
	case tblauthclient.EdgeClientToken:
		m.ResetClientToken()
		return nil
	}
	return fmt.Errorf("unknown TblAuthClient edge %s", name)
}

// TblAuthTokenMutation represents an operation that mutates the TblAuthToken nodes in the graph.
type TblAuthTokenMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	auth_uuid                *string
	auth_xref                *string
	accesstoken              *string
	accesstokencreatedat     *time.Time
	accesstokenexpiresin     *int
	addaccesstokenexpiresin  *int
	refreshtoken             *string
	refreshtokencreatedat    *time.Time
	refreshtokenexpiresin    *int
	addrefreshtokenexpiresin *int
	createdat                *time.Time
	updatedat                *time.Time
	deletedat                *time.Time
	ip_address               *string
	useragent                *string
	createdby                *string
	updatedby                *string
	deletedby                *string
	code                     *string
	codecreatedat            *time.Time
	codeexpiresin            *int
	addcodeexpiresin         *int
	codechallenge            *string
	redirect_uri             *string
	scope                    *string
	clearedFields            map[string]struct{}
	_TokenClient             *string
	cleared_TokenClient      bool
	_TokenUser               *string
	cleared_TokenUser        bool
	done                     bool
	oldValue                 func(context.Context) (*TblAuthToken, error)
	predicates               []predicate.TblAuthToken
}

var _ ent.Mutation = (*TblAuthTokenMutation)(nil)

// tblauthtokenOption allows management of the mutation configuration using functional options.
type tblauthtokenOption func(*TblAuthTokenMutation)

// newTblAuthTokenMutation creates new mutation for the TblAuthToken entity.
func newTblAuthTokenMutation(c config, op Op, opts ...tblauthtokenOption) *TblAuthTokenMutation {
	m := &TblAuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeTblAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblAuthTokenID sets the ID field of the mutation.
func withTblAuthTokenID(id string) tblauthtokenOption {
	return func(m *TblAuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *TblAuthToken
		)
		m.oldValue = func(ctx context.Context) (*TblAuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblAuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblAuthToken sets the old TblAuthToken of the mutation.
func withTblAuthToken(node *TblAuthToken) tblauthtokenOption {
	return func(m *TblAuthTokenMutation) {
		m.oldValue = func(context.Context) (*TblAuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblAuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblAuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblAuthToken entities.
func (m *TblAuthTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblAuthTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblAuthTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblAuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthUUID sets the "auth_uuid" field.
func (m *TblAuthTokenMutation) SetAuthUUID(s string) {
	m.auth_uuid = &s
}

// AuthUUID returns the value of the "auth_uuid" field in the mutation.
func (m *TblAuthTokenMutation) AuthUUID() (r string, exists bool) {
	v := m.auth_uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthUUID returns the old "auth_uuid" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldAuthUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthUUID: %w", err)
	}
	return oldValue.AuthUUID, nil
}

// ResetAuthUUID resets all changes to the "auth_uuid" field.
func (m *TblAuthTokenMutation) ResetAuthUUID() {
	m.auth_uuid = nil
}

// SetAuthXref sets the "auth_xref" field.
func (m *TblAuthTokenMutation) SetAuthXref(s string) {
	m.auth_xref = &s
}

// AuthXref returns the value of the "auth_xref" field in the mutation.
func (m *TblAuthTokenMutation) AuthXref() (r string, exists bool) {
	v := m.auth_xref
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthXref returns the old "auth_xref" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldAuthXref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthXref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthXref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthXref: %w", err)
	}
	return oldValue.AuthXref, nil
}

// ResetAuthXref resets all changes to the "auth_xref" field.
func (m *TblAuthTokenMutation) ResetAuthXref() {
	m.auth_xref = nil
}

// SetAccesstoken sets the "accesstoken" field.
func (m *TblAuthTokenMutation) SetAccesstoken(s string) {
	m.accesstoken = &s
}

// Accesstoken returns the value of the "accesstoken" field in the mutation.
func (m *TblAuthTokenMutation) Accesstoken() (r string, exists bool) {
	v := m.accesstoken
	if v == nil {
		return
	}
	return *v, true
}

// OldAccesstoken returns the old "accesstoken" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldAccesstoken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccesstoken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccesstoken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccesstoken: %w", err)
	}
	return oldValue.Accesstoken, nil
}

// ResetAccesstoken resets all changes to the "accesstoken" field.
func (m *TblAuthTokenMutation) ResetAccesstoken() {
	m.accesstoken = nil
}

// SetAccesstokencreatedat sets the "accesstokencreatedat" field.
func (m *TblAuthTokenMutation) SetAccesstokencreatedat(t time.Time) {
	m.accesstokencreatedat = &t
}

// Accesstokencreatedat returns the value of the "accesstokencreatedat" field in the mutation.
func (m *TblAuthTokenMutation) Accesstokencreatedat() (r time.Time, exists bool) {
	v := m.accesstokencreatedat
	if v == nil {
		return
	}
	return *v, true
}

// OldAccesstokencreatedat returns the old "accesstokencreatedat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldAccesstokencreatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccesstokencreatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccesstokencreatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccesstokencreatedat: %w", err)
	}
	return oldValue.Accesstokencreatedat, nil
}

// ResetAccesstokencreatedat resets all changes to the "accesstokencreatedat" field.
func (m *TblAuthTokenMutation) ResetAccesstokencreatedat() {
	m.accesstokencreatedat = nil
}

// SetAccesstokenexpiresin sets the "accesstokenexpiresin" field.
func (m *TblAuthTokenMutation) SetAccesstokenexpiresin(i int) {
	m.accesstokenexpiresin = &i
	m.addaccesstokenexpiresin = nil
}

// Accesstokenexpiresin returns the value of the "accesstokenexpiresin" field in the mutation.
func (m *TblAuthTokenMutation) Accesstokenexpiresin() (r int, exists bool) {
	v := m.accesstokenexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// OldAccesstokenexpiresin returns the old "accesstokenexpiresin" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldAccesstokenexpiresin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccesstokenexpiresin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccesstokenexpiresin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccesstokenexpiresin: %w", err)
	}
	return oldValue.Accesstokenexpiresin, nil
}

// AddAccesstokenexpiresin adds i to the "accesstokenexpiresin" field.
func (m *TblAuthTokenMutation) AddAccesstokenexpiresin(i int) {
	if m.addaccesstokenexpiresin != nil {
		*m.addaccesstokenexpiresin += i
	} else {
		m.addaccesstokenexpiresin = &i
	}
}

// AddedAccesstokenexpiresin returns the value that was added to the "accesstokenexpiresin" field in this mutation.
func (m *TblAuthTokenMutation) AddedAccesstokenexpiresin() (r int, exists bool) {
	v := m.addaccesstokenexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccesstokenexpiresin resets all changes to the "accesstokenexpiresin" field.
func (m *TblAuthTokenMutation) ResetAccesstokenexpiresin() {
	m.accesstokenexpiresin = nil
	m.addaccesstokenexpiresin = nil
}

// SetClientid sets the "clientid" field.
func (m *TblAuthTokenMutation) SetClientid(s string) {
	m._TokenClient = &s
}

// Clientid returns the value of the "clientid" field in the mutation.
func (m *TblAuthTokenMutation) Clientid() (r string, exists bool) {
	v := m._TokenClient
	if v == nil {
		return
	}
	return *v, true
}

// OldClientid returns the old "clientid" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldClientid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientid: %w", err)
	}
	return oldValue.Clientid, nil
}

// ClearClientid clears the value of the "clientid" field.
func (m *TblAuthTokenMutation) ClearClientid() {
	m._TokenClient = nil
	m.clearedFields[tblauthtoken.FieldClientid] = struct{}{}
}

// ClientidCleared returns if the "clientid" field was cleared in this mutation.
func (m *TblAuthTokenMutation) ClientidCleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldClientid]
	return ok
}

// ResetClientid resets all changes to the "clientid" field.
func (m *TblAuthTokenMutation) ResetClientid() {
	m._TokenClient = nil
	delete(m.clearedFields, tblauthtoken.FieldClientid)
}

// SetUserUlid sets the "user_ulid" field.
func (m *TblAuthTokenMutation) SetUserUlid(s string) {
	m._TokenUser = &s
}

// UserUlid returns the value of the "user_ulid" field in the mutation.
func (m *TblAuthTokenMutation) UserUlid() (r string, exists bool) {
	v := m._TokenUser
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUlid returns the old "user_ulid" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldUserUlid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserUlid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserUlid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUlid: %w", err)
	}
	return oldValue.UserUlid, nil
}

// ClearUserUlid clears the value of the "user_ulid" field.
func (m *TblAuthTokenMutation) ClearUserUlid() {
	m._TokenUser = nil
	m.clearedFields[tblauthtoken.FieldUserUlid] = struct{}{}
}

// UserUlidCleared returns if the "user_ulid" field was cleared in this mutation.
func (m *TblAuthTokenMutation) UserUlidCleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldUserUlid]
	return ok
}

// ResetUserUlid resets all changes to the "user_ulid" field.
func (m *TblAuthTokenMutation) ResetUserUlid() {
	m._TokenUser = nil
	delete(m.clearedFields, tblauthtoken.FieldUserUlid)
}

// SetRefreshtoken sets the "refreshtoken" field.
func (m *TblAuthTokenMutation) SetRefreshtoken(s string) {
	m.refreshtoken = &s
}

// Refreshtoken returns the value of the "refreshtoken" field in the mutation.
func (m *TblAuthTokenMutation) Refreshtoken() (r string, exists bool) {
	v := m.refreshtoken
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshtoken returns the old "refreshtoken" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldRefreshtoken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshtoken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshtoken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshtoken: %w", err)
	}
	return oldValue.Refreshtoken, nil
}

// ResetRefreshtoken resets all changes to the "refreshtoken" field.
func (m *TblAuthTokenMutation) ResetRefreshtoken() {
	m.refreshtoken = nil
}

// SetRefreshtokencreatedat sets the "refreshtokencreatedat" field.
func (m *TblAuthTokenMutation) SetRefreshtokencreatedat(t time.Time) {
	m.refreshtokencreatedat = &t
}

// Refreshtokencreatedat returns the value of the "refreshtokencreatedat" field in the mutation.
func (m *TblAuthTokenMutation) Refreshtokencreatedat() (r time.Time, exists bool) {
	v := m.refreshtokencreatedat
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshtokencreatedat returns the old "refreshtokencreatedat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldRefreshtokencreatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshtokencreatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshtokencreatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshtokencreatedat: %w", err)
	}
	return oldValue.Refreshtokencreatedat, nil
}

// ResetRefreshtokencreatedat resets all changes to the "refreshtokencreatedat" field.
func (m *TblAuthTokenMutation) ResetRefreshtokencreatedat() {
	m.refreshtokencreatedat = nil
}

// SetRefreshtokenexpiresin sets the "refreshtokenexpiresin" field.
func (m *TblAuthTokenMutation) SetRefreshtokenexpiresin(i int) {
	m.refreshtokenexpiresin = &i
	m.addrefreshtokenexpiresin = nil
}

// Refreshtokenexpiresin returns the value of the "refreshtokenexpiresin" field in the mutation.
func (m *TblAuthTokenMutation) Refreshtokenexpiresin() (r int, exists bool) {
	v := m.refreshtokenexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshtokenexpiresin returns the old "refreshtokenexpiresin" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldRefreshtokenexpiresin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshtokenexpiresin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshtokenexpiresin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshtokenexpiresin: %w", err)
	}
	return oldValue.Refreshtokenexpiresin, nil
}

// AddRefreshtokenexpiresin adds i to the "refreshtokenexpiresin" field.
func (m *TblAuthTokenMutation) AddRefreshtokenexpiresin(i int) {
	if m.addrefreshtokenexpiresin != nil {
		*m.addrefreshtokenexpiresin += i
	} else {
		m.addrefreshtokenexpiresin = &i
	}
}

// AddedRefreshtokenexpiresin returns the value that was added to the "refreshtokenexpiresin" field in this mutation.
func (m *TblAuthTokenMutation) AddedRefreshtokenexpiresin() (r int, exists bool) {
	v := m.addrefreshtokenexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// ResetRefreshtokenexpiresin resets all changes to the "refreshtokenexpiresin" field.
func (m *TblAuthTokenMutation) ResetRefreshtokenexpiresin() {
	m.refreshtokenexpiresin = nil
	m.addrefreshtokenexpiresin = nil
}

// SetCreatedat sets the "createdat" field.
func (m *TblAuthTokenMutation) SetCreatedat(t time.Time) {
	m.createdat = &t
}

// Createdat returns the value of the "createdat" field in the mutation.
func (m *TblAuthTokenMutation) Createdat() (r time.Time, exists bool) {
	v := m.createdat
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedat returns the old "createdat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCreatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedat: %w", err)
	}
	return oldValue.Createdat, nil
}

// ResetCreatedat resets all changes to the "createdat" field.
func (m *TblAuthTokenMutation) ResetCreatedat() {
	m.createdat = nil
}

// SetUpdatedat sets the "updatedat" field.
func (m *TblAuthTokenMutation) SetUpdatedat(t time.Time) {
	m.updatedat = &t
}

// Updatedat returns the value of the "updatedat" field in the mutation.
func (m *TblAuthTokenMutation) Updatedat() (r time.Time, exists bool) {
	v := m.updatedat
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedat returns the old "updatedat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldUpdatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedat: %w", err)
	}
	return oldValue.Updatedat, nil
}

// ResetUpdatedat resets all changes to the "updatedat" field.
func (m *TblAuthTokenMutation) ResetUpdatedat() {
	m.updatedat = nil
}

// SetDeletedat sets the "deletedat" field.
func (m *TblAuthTokenMutation) SetDeletedat(t time.Time) {
	m.deletedat = &t
}

// Deletedat returns the value of the "deletedat" field in the mutation.
func (m *TblAuthTokenMutation) Deletedat() (r time.Time, exists bool) {
	v := m.deletedat
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedat returns the old "deletedat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldDeletedat(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedat: %w", err)
	}
	return oldValue.Deletedat, nil
}

// ClearDeletedat clears the value of the "deletedat" field.
func (m *TblAuthTokenMutation) ClearDeletedat() {
	m.deletedat = nil
	m.clearedFields[tblauthtoken.FieldDeletedat] = struct{}{}
}

// DeletedatCleared returns if the "deletedat" field was cleared in this mutation.
func (m *TblAuthTokenMutation) DeletedatCleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldDeletedat]
	return ok
}

// ResetDeletedat resets all changes to the "deletedat" field.
func (m *TblAuthTokenMutation) ResetDeletedat() {
	m.deletedat = nil
	delete(m.clearedFields, tblauthtoken.FieldDeletedat)
}

// SetIPAddress sets the "ip_address" field.
func (m *TblAuthTokenMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *TblAuthTokenMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldIPAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *TblAuthTokenMutation) ResetIPAddress() {
	m.ip_address = nil
}

// SetUseragent sets the "useragent" field.
func (m *TblAuthTokenMutation) SetUseragent(s string) {
	m.useragent = &s
}

// Useragent returns the value of the "useragent" field in the mutation.
func (m *TblAuthTokenMutation) Useragent() (r string, exists bool) {
	v := m.useragent
	if v == nil {
		return
	}
	return *v, true
}

// OldUseragent returns the old "useragent" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldUseragent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseragent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseragent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseragent: %w", err)
	}
	return oldValue.Useragent, nil
}

// ResetUseragent resets all changes to the "useragent" field.
func (m *TblAuthTokenMutation) ResetUseragent() {
	m.useragent = nil
}

// SetCreatedby sets the "createdby" field.
func (m *TblAuthTokenMutation) SetCreatedby(s string) {
	m.createdby = &s
}

// Createdby returns the value of the "createdby" field in the mutation.
func (m *TblAuthTokenMutation) Createdby() (r string, exists bool) {
	v := m.createdby
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedby returns the old "createdby" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCreatedby(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedby is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedby requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedby: %w", err)
	}
	return oldValue.Createdby, nil
}

// ResetCreatedby resets all changes to the "createdby" field.
func (m *TblAuthTokenMutation) ResetCreatedby() {
	m.createdby = nil
}

// SetUpdatedby sets the "updatedby" field.
func (m *TblAuthTokenMutation) SetUpdatedby(s string) {
	m.updatedby = &s
}

// Updatedby returns the value of the "updatedby" field in the mutation.
func (m *TblAuthTokenMutation) Updatedby() (r string, exists bool) {
	v := m.updatedby
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedby returns the old "updatedby" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldUpdatedby(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedby is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedby requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedby: %w", err)
	}
	return oldValue.Updatedby, nil
}

// ResetUpdatedby resets all changes to the "updatedby" field.
func (m *TblAuthTokenMutation) ResetUpdatedby() {
	m.updatedby = nil
}

// SetDeletedby sets the "deletedby" field.
func (m *TblAuthTokenMutation) SetDeletedby(s string) {
	m.deletedby = &s
}

// Deletedby returns the value of the "deletedby" field in the mutation.
func (m *TblAuthTokenMutation) Deletedby() (r string, exists bool) {
	v := m.deletedby
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedby returns the old "deletedby" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldDeletedby(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedby is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedby requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedby: %w", err)
	}
	return oldValue.Deletedby, nil
}

// ClearDeletedby clears the value of the "deletedby" field.
func (m *TblAuthTokenMutation) ClearDeletedby() {
	m.deletedby = nil
	m.clearedFields[tblauthtoken.FieldDeletedby] = struct{}{}
}

// DeletedbyCleared returns if the "deletedby" field was cleared in this mutation.
func (m *TblAuthTokenMutation) DeletedbyCleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldDeletedby]
	return ok
}

// ResetDeletedby resets all changes to the "deletedby" field.
func (m *TblAuthTokenMutation) ResetDeletedby() {
	m.deletedby = nil
	delete(m.clearedFields, tblauthtoken.FieldDeletedby)
}

// SetCode sets the "code" field.
func (m *TblAuthTokenMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TblAuthTokenMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TblAuthTokenMutation) ResetCode() {
	m.code = nil
}

// SetCodecreatedat sets the "codecreatedat" field.
func (m *TblAuthTokenMutation) SetCodecreatedat(t time.Time) {
	m.codecreatedat = &t
}

// Codecreatedat returns the value of the "codecreatedat" field in the mutation.
func (m *TblAuthTokenMutation) Codecreatedat() (r time.Time, exists bool) {
	v := m.codecreatedat
	if v == nil {
		return
	}
	return *v, true
}

// OldCodecreatedat returns the old "codecreatedat" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCodecreatedat(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodecreatedat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodecreatedat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodecreatedat: %w", err)
	}
	return oldValue.Codecreatedat, nil
}

// ResetCodecreatedat resets all changes to the "codecreatedat" field.
func (m *TblAuthTokenMutation) ResetCodecreatedat() {
	m.codecreatedat = nil
}

// SetCodeexpiresin sets the "codeexpiresin" field.
func (m *TblAuthTokenMutation) SetCodeexpiresin(i int) {
	m.codeexpiresin = &i
	m.addcodeexpiresin = nil
}

// Codeexpiresin returns the value of the "codeexpiresin" field in the mutation.
func (m *TblAuthTokenMutation) Codeexpiresin() (r int, exists bool) {
	v := m.codeexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeexpiresin returns the old "codeexpiresin" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCodeexpiresin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeexpiresin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeexpiresin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeexpiresin: %w", err)
	}
	return oldValue.Codeexpiresin, nil
}

// AddCodeexpiresin adds i to the "codeexpiresin" field.
func (m *TblAuthTokenMutation) AddCodeexpiresin(i int) {
	if m.addcodeexpiresin != nil {
		*m.addcodeexpiresin += i
	} else {
		m.addcodeexpiresin = &i
	}
}

// AddedCodeexpiresin returns the value that was added to the "codeexpiresin" field in this mutation.
func (m *TblAuthTokenMutation) AddedCodeexpiresin() (r int, exists bool) {
	v := m.addcodeexpiresin
	if v == nil {
		return
	}
	return *v, true
}

// ResetCodeexpiresin resets all changes to the "codeexpiresin" field.
func (m *TblAuthTokenMutation) ResetCodeexpiresin() {
	m.codeexpiresin = nil
	m.addcodeexpiresin = nil
}

// SetCodechallenge sets the "codechallenge" field.
func (m *TblAuthTokenMutation) SetCodechallenge(s string) {
	m.codechallenge = &s
}

// Codechallenge returns the value of the "codechallenge" field in the mutation.
func (m *TblAuthTokenMutation) Codechallenge() (r string, exists bool) {
	v := m.codechallenge
	if v == nil {
		return
	}
	return *v, true
}

// OldCodechallenge returns the old "codechallenge" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldCodechallenge(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodechallenge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodechallenge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodechallenge: %w", err)
	}
	return oldValue.Codechallenge, nil
}

// ClearCodechallenge clears the value of the "codechallenge" field.
func (m *TblAuthTokenMutation) ClearCodechallenge() {
	m.codechallenge = nil
	m.clearedFields[tblauthtoken.FieldCodechallenge] = struct{}{}
}

// CodechallengeCleared returns if the "codechallenge" field was cleared in this mutation.
func (m *TblAuthTokenMutation) CodechallengeCleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldCodechallenge]
	return ok
}

// ResetCodechallenge resets all changes to the "codechallenge" field.
func (m *TblAuthTokenMutation) ResetCodechallenge() {
	m.codechallenge = nil
	delete(m.clearedFields, tblauthtoken.FieldCodechallenge)
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *TblAuthTokenMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *TblAuthTokenMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldRedirectURI(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ClearRedirectURI clears the value of the "redirect_uri" field.
func (m *TblAuthTokenMutation) ClearRedirectURI() {
	m.redirect_uri = nil
	m.clearedFields[tblauthtoken.FieldRedirectURI] = struct{}{}
}

// RedirectURICleared returns if the "redirect_uri" field was cleared in this mutation.
func (m *TblAuthTokenMutation) RedirectURICleared() bool {
	_, ok := m.clearedFields[tblauthtoken.FieldRedirectURI]
	return ok
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *TblAuthTokenMutation) ResetRedirectURI() {
	m.redirect_uri = nil
	delete(m.clearedFields, tblauthtoken.FieldRedirectURI)
}

// SetScope sets the "scope" field.
func (m *TblAuthTokenMutation) SetScope(s string) {
	m.scope = &s
}

// Scope returns the value of the "scope" field in the mutation.
func (m *TblAuthTokenMutation) Scope() (r string, exists bool) {
	v := m.scope
	if v == nil {
		return
	}
	return *v, true
}

// OldScope returns the old "scope" field's value of the TblAuthToken entity.
// If the TblAuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblAuthTokenMutation) OldScope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScope: %w", err)
	}
	return oldValue.Scope, nil
}

// ResetScope resets all changes to the "scope" field.
func (m *TblAuthTokenMutation) ResetScope() {
	m.scope = nil
}

// SetTokenClientID sets the "TokenClient" edge to the TblAuthClient entity by id.
func (m *TblAuthTokenMutation) SetTokenClientID(id string) {
	m._TokenClient = &id
}

// ClearTokenClient clears the "TokenClient" edge to the TblAuthClient entity.
func (m *TblAuthTokenMutation) ClearTokenClient() {
	m.cleared_TokenClient = true
	m.clearedFields[tblauthtoken.FieldClientid] = struct{}{}
}

// TokenClientCleared reports if the "TokenClient" edge to the TblAuthClient entity was cleared.
func (m *TblAuthTokenMutation) TokenClientCleared() bool {
	return m.ClientidCleared() || m.cleared_TokenClient
}

// TokenClientID returns the "TokenClient" edge ID in the mutation.
func (m *TblAuthTokenMutation) TokenClientID() (id string, exists bool) {
	if m._TokenClient != nil {
		return *m._TokenClient, true
	}
	return
}

// TokenClientIDs returns the "TokenClient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenClientID instead. It exists only for internal usage by the builders.
func (m *TblAuthTokenMutation) TokenClientIDs() (ids []string) {
	if id := m._TokenClient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenClient resets all changes to the "TokenClient" edge.
func (m *TblAuthTokenMutation) ResetTokenClient() {
	m._TokenClient = nil
	m.cleared_TokenClient = false
}

// SetTokenUserID sets the "TokenUser" edge to the TblUser entity by id.
func (m *TblAuthTokenMutation) SetTokenUserID(id string) {
	m._TokenUser = &id
}

// ClearTokenUser clears the "TokenUser" edge to the TblUser entity.
func (m *TblAuthTokenMutation) ClearTokenUser() {
	m.cleared_TokenUser = true
	m.clearedFields[tblauthtoken.FieldUserUlid] = struct{}{}
}

// TokenUserCleared reports if the "TokenUser" edge to the TblUser entity was cleared.
func (m *TblAuthTokenMutation) TokenUserCleared() bool {
	return m.UserUlidCleared() || m.cleared_TokenUser
}

// TokenUserID returns the "TokenUser" edge ID in the mutation.
func (m *TblAuthTokenMutation) TokenUserID() (id string, exists bool) {
	if m._TokenUser != nil {
		return *m._TokenUser, true
	}
	return
}

// TokenUserIDs returns the "TokenUser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TokenUserID instead. It exists only for internal usage by the builders.
func (m *TblAuthTokenMutation) TokenUserIDs() (ids []string) {
	if id := m._TokenUser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTokenUser resets all changes to the "TokenUser" edge.
func (m *TblAuthTokenMutation) ResetTokenUser() {
	m._TokenUser = nil
	m.cleared_TokenUser = false
}

// Where appends a list predicates to the TblAuthTokenMutation builder.
func (m *TblAuthTokenMutation) Where(ps ...predicate.TblAuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblAuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblAuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblAuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblAuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblAuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblAuthToken).
func (m *TblAuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblAuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.auth_uuid != nil {
		fields = append(fields, tblauthtoken.FieldAuthUUID)
	}
	if m.auth_xref != nil {
		fields = append(fields, tblauthtoken.FieldAuthXref)
	}
	if m.accesstoken != nil {
		fields = append(fields, tblauthtoken.FieldAccesstoken)
	}
	if m.accesstokencreatedat != nil {
		fields = append(fields, tblauthtoken.FieldAccesstokencreatedat)
	}
	if m.accesstokenexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldAccesstokenexpiresin)
	}
	if m._TokenClient != nil {
		fields = append(fields, tblauthtoken.FieldClientid)
	}
	if m._TokenUser != nil {
		fields = append(fields, tblauthtoken.FieldUserUlid)
	}
	if m.refreshtoken != nil {
		fields = append(fields, tblauthtoken.FieldRefreshtoken)
	}
	if m.refreshtokencreatedat != nil {
		fields = append(fields, tblauthtoken.FieldRefreshtokencreatedat)
	}
	if m.refreshtokenexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldRefreshtokenexpiresin)
	}
	if m.createdat != nil {
		fields = append(fields, tblauthtoken.FieldCreatedat)
	}
	if m.updatedat != nil {
		fields = append(fields, tblauthtoken.FieldUpdatedat)
	}
	if m.deletedat != nil {
		fields = append(fields, tblauthtoken.FieldDeletedat)
	}
	if m.ip_address != nil {
		fields = append(fields, tblauthtoken.FieldIPAddress)
	}
	if m.useragent != nil {
		fields = append(fields, tblauthtoken.FieldUseragent)
	}
	if m.createdby != nil {
		fields = append(fields, tblauthtoken.FieldCreatedby)
	}
	if m.updatedby != nil {
		fields = append(fields, tblauthtoken.FieldUpdatedby)
	}
	if m.deletedby != nil {
		fields = append(fields, tblauthtoken.FieldDeletedby)
	}
	if m.code != nil {
		fields = append(fields, tblauthtoken.FieldCode)
	}
	if m.codecreatedat != nil {
		fields = append(fields, tblauthtoken.FieldCodecreatedat)
	}
	if m.codeexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldCodeexpiresin)
	}
	if m.codechallenge != nil {
		fields = append(fields, tblauthtoken.FieldCodechallenge)
	}
	if m.redirect_uri != nil {
		fields = append(fields, tblauthtoken.FieldRedirectURI)
	}
	if m.scope != nil {
		fields = append(fields, tblauthtoken.FieldScope)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblAuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblauthtoken.FieldAuthUUID:
		return m.AuthUUID()
	case tblauthtoken.FieldAuthXref:
		return m.AuthXref()
	case tblauthtoken.FieldAccesstoken:
		return m.Accesstoken()
	case tblauthtoken.FieldAccesstokencreatedat:
		return m.Accesstokencreatedat()
	case tblauthtoken.FieldAccesstokenexpiresin:
		return m.Accesstokenexpiresin()
	case tblauthtoken.FieldClientid:
		return m.Clientid()
	case tblauthtoken.FieldUserUlid:
		return m.UserUlid()
	case tblauthtoken.FieldRefreshtoken:
		return m.Refreshtoken()
	case tblauthtoken.FieldRefreshtokencreatedat:
		return m.Refreshtokencreatedat()
	case tblauthtoken.FieldRefreshtokenexpiresin:
		return m.Refreshtokenexpiresin()
	case tblauthtoken.FieldCreatedat:
		return m.Createdat()
	case tblauthtoken.FieldUpdatedat:
		return m.Updatedat()
	case tblauthtoken.FieldDeletedat:
		return m.Deletedat()
	case tblauthtoken.FieldIPAddress:
		return m.IPAddress()
	case tblauthtoken.FieldUseragent:
		return m.Useragent()
	case tblauthtoken.FieldCreatedby:
		return m.Createdby()
	case tblauthtoken.FieldUpdatedby:
		return m.Updatedby()
	case tblauthtoken.FieldDeletedby:
		return m.Deletedby()
	case tblauthtoken.FieldCode:
		return m.Code()
	case tblauthtoken.FieldCodecreatedat:
		return m.Codecreatedat()
	case tblauthtoken.FieldCodeexpiresin:
		return m.Codeexpiresin()
	case tblauthtoken.FieldCodechallenge:
		return m.Codechallenge()
	case tblauthtoken.FieldRedirectURI:
		return m.RedirectURI()
	case tblauthtoken.FieldScope:
		return m.Scope()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblAuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblauthtoken.FieldAuthUUID:
		return m.OldAuthUUID(ctx)
	case tblauthtoken.FieldAuthXref:
		return m.OldAuthXref(ctx)
	case tblauthtoken.FieldAccesstoken:
		return m.OldAccesstoken(ctx)
	case tblauthtoken.FieldAccesstokencreatedat:
		return m.OldAccesstokencreatedat(ctx)
	case tblauthtoken.FieldAccesstokenexpiresin:
		return m.OldAccesstokenexpiresin(ctx)
	case tblauthtoken.FieldClientid:
		return m.OldClientid(ctx)
	case tblauthtoken.FieldUserUlid:
		return m.OldUserUlid(ctx)
	case tblauthtoken.FieldRefreshtoken:
		return m.OldRefreshtoken(ctx)
	case tblauthtoken.FieldRefreshtokencreatedat:
		return m.OldRefreshtokencreatedat(ctx)
	case tblauthtoken.FieldRefreshtokenexpiresin:
		return m.OldRefreshtokenexpiresin(ctx)
	case tblauthtoken.FieldCreatedat:
		return m.OldCreatedat(ctx)
	case tblauthtoken.FieldUpdatedat:
		return m.OldUpdatedat(ctx)
	case tblauthtoken.FieldDeletedat:
		return m.OldDeletedat(ctx)
	case tblauthtoken.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case tblauthtoken.FieldUseragent:
		return m.OldUseragent(ctx)
	case tblauthtoken.FieldCreatedby:
		return m.OldCreatedby(ctx)
	case tblauthtoken.FieldUpdatedby:
		return m.OldUpdatedby(ctx)
	case tblauthtoken.FieldDeletedby:
		return m.OldDeletedby(ctx)
	case tblauthtoken.FieldCode:
		return m.OldCode(ctx)
	case tblauthtoken.FieldCodecreatedat:
		return m.OldCodecreatedat(ctx)
	case tblauthtoken.FieldCodeexpiresin:
		return m.OldCodeexpiresin(ctx)
	case tblauthtoken.FieldCodechallenge:
		return m.OldCodechallenge(ctx)
	case tblauthtoken.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case tblauthtoken.FieldScope:
		return m.OldScope(ctx)
	}
	return nil, fmt.Errorf("unknown TblAuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblAuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblauthtoken.FieldAuthUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthUUID(v)
		return nil
	case tblauthtoken.FieldAuthXref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthXref(v)
		return nil
	case tblauthtoken.FieldAccesstoken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccesstoken(v)
		return nil
	case tblauthtoken.FieldAccesstokencreatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccesstokencreatedat(v)
		return nil
	case tblauthtoken.FieldAccesstokenexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccesstokenexpiresin(v)
		return nil
	case tblauthtoken.FieldClientid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientid(v)
		return nil
	case tblauthtoken.FieldUserUlid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUlid(v)
		return nil
	case tblauthtoken.FieldRefreshtoken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshtoken(v)
		return nil
	case tblauthtoken.FieldRefreshtokencreatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshtokencreatedat(v)
		return nil
	case tblauthtoken.FieldRefreshtokenexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshtokenexpiresin(v)
		return nil
	case tblauthtoken.FieldCreatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedat(v)
		return nil
	case tblauthtoken.FieldUpdatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedat(v)
		return nil
	case tblauthtoken.FieldDeletedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedat(v)
		return nil
	case tblauthtoken.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case tblauthtoken.FieldUseragent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseragent(v)
		return nil
	case tblauthtoken.FieldCreatedby:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedby(v)
		return nil
	case tblauthtoken.FieldUpdatedby:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedby(v)
		return nil
	case tblauthtoken.FieldDeletedby:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedby(v)
		return nil
	case tblauthtoken.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tblauthtoken.FieldCodecreatedat:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodecreatedat(v)
		return nil
	case tblauthtoken.FieldCodeexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeexpiresin(v)
		return nil
	case tblauthtoken.FieldCodechallenge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodechallenge(v)
		return nil
	case tblauthtoken.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case tblauthtoken.FieldScope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScope(v)
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblAuthTokenMutation) AddedFields() []string {
	var fields []string
	if m.addaccesstokenexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldAccesstokenexpiresin)
	}
	if m.addrefreshtokenexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldRefreshtokenexpiresin)
	}
	if m.addcodeexpiresin != nil {
		fields = append(fields, tblauthtoken.FieldCodeexpiresin)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblAuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tblauthtoken.FieldAccesstokenexpiresin:
		return m.AddedAccesstokenexpiresin()
	case tblauthtoken.FieldRefreshtokenexpiresin:
		return m.AddedRefreshtokenexpiresin()
	case tblauthtoken.FieldCodeexpiresin:
		return m.AddedCodeexpiresin()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblAuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tblauthtoken.FieldAccesstokenexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccesstokenexpiresin(v)
		return nil
	case tblauthtoken.FieldRefreshtokenexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRefreshtokenexpiresin(v)
		return nil
	case tblauthtoken.FieldCodeexpiresin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCodeexpiresin(v)
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblAuthTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblauthtoken.FieldClientid) {
		fields = append(fields, tblauthtoken.FieldClientid)
	}
	if m.FieldCleared(tblauthtoken.FieldUserUlid) {
		fields = append(fields, tblauthtoken.FieldUserUlid)
	}
	if m.FieldCleared(tblauthtoken.FieldDeletedat) {
		fields = append(fields, tblauthtoken.FieldDeletedat)
	}
	if m.FieldCleared(tblauthtoken.FieldDeletedby) {
		fields = append(fields, tblauthtoken.FieldDeletedby)
	}
	if m.FieldCleared(tblauthtoken.FieldCodechallenge) {
		fields = append(fields, tblauthtoken.FieldCodechallenge)
	}
	if m.FieldCleared(tblauthtoken.FieldRedirectURI) {
		fields = append(fields, tblauthtoken.FieldRedirectURI)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblAuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblAuthTokenMutation) ClearField(name string) error {
	switch name {
	case tblauthtoken.FieldClientid:
		m.ClearClientid()
		return nil
	case tblauthtoken.FieldUserUlid:
		m.ClearUserUlid()
		return nil
	case tblauthtoken.FieldDeletedat:
		m.ClearDeletedat()
		return nil
	case tblauthtoken.FieldDeletedby:
		m.ClearDeletedby()
		return nil
	case tblauthtoken.FieldCodechallenge:
		m.ClearCodechallenge()
		return nil
	case tblauthtoken.FieldRedirectURI:
		m.ClearRedirectURI()
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblAuthTokenMutation) ResetField(name string) error {
	switch name {
	case tblauthtoken.FieldAuthUUID:
		m.ResetAuthUUID()
		return nil
	case tblauthtoken.FieldAuthXref:
		m.ResetAuthXref()
		return nil
	case tblauthtoken.FieldAccesstoken:
		m.ResetAccesstoken()
		return nil
	case tblauthtoken.FieldAccesstokencreatedat:
		m.ResetAccesstokencreatedat()
		return nil
	case tblauthtoken.FieldAccesstokenexpiresin:
		m.ResetAccesstokenexpiresin()
		return nil
	case tblauthtoken.FieldClientid:
		m.ResetClientid()
		return nil
	case tblauthtoken.FieldUserUlid:
		m.ResetUserUlid()
		return nil
	case tblauthtoken.FieldRefreshtoken:
		m.ResetRefreshtoken()
		return nil
	case tblauthtoken.FieldRefreshtokencreatedat:
		m.ResetRefreshtokencreatedat()
		return nil
	case tblauthtoken.FieldRefreshtokenexpiresin:
		m.ResetRefreshtokenexpiresin()
		return nil
	case tblauthtoken.FieldCreatedat:
		m.ResetCreatedat()
		return nil
	case tblauthtoken.FieldUpdatedat:
		m.ResetUpdatedat()
		return nil
	case tblauthtoken.FieldDeletedat:
		m.ResetDeletedat()
		return nil
	case tblauthtoken.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case tblauthtoken.FieldUseragent:
		m.ResetUseragent()
		return nil
	case tblauthtoken.FieldCreatedby:
		m.ResetCreatedby()
		return nil
	case tblauthtoken.FieldUpdatedby:
		m.ResetUpdatedby()
		return nil
	case tblauthtoken.FieldDeletedby:
		m.ResetDeletedby()
		return nil
	case tblauthtoken.FieldCode:
		m.ResetCode()
		return nil
	case tblauthtoken.FieldCodecreatedat:
		m.ResetCodecreatedat()
		return nil
	case tblauthtoken.FieldCodeexpiresin:
		m.ResetCodeexpiresin()
		return nil
	case tblauthtoken.FieldCodechallenge:
		m.ResetCodechallenge()
		return nil
	case tblauthtoken.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case tblauthtoken.FieldScope:
		m.ResetScope()
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblAuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._TokenClient != nil {
		edges = append(edges, tblauthtoken.EdgeTokenClient)
	}
	if m._TokenUser != nil {
		edges = append(edges, tblauthtoken.EdgeTokenUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblAuthTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblauthtoken.EdgeTokenClient:
		if id := m._TokenClient; id != nil {
			return []ent.Value{*id}
		}
	case tblauthtoken.EdgeTokenUser:
		if id := m._TokenUser; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblAuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblAuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblAuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_TokenClient {
		edges = append(edges, tblauthtoken.EdgeTokenClient)
	}
	if m.cleared_TokenUser {
		edges = append(edges, tblauthtoken.EdgeTokenUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblAuthTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case tblauthtoken.EdgeTokenClient:
		return m.cleared_TokenClient
	case tblauthtoken.EdgeTokenUser:
		return m.cleared_TokenUser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblAuthTokenMutation) ClearEdge(name string) error {
	switch name {
	case tblauthtoken.EdgeTokenClient:
		m.ClearTokenClient()
		return nil
	case tblauthtoken.EdgeTokenUser:
		m.ClearTokenUser()
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblAuthTokenMutation) ResetEdge(name string) error {
	switch name {
	case tblauthtoken.EdgeTokenClient:
		m.ResetTokenClient()
		return nil
	case tblauthtoken.EdgeTokenUser:
		m.ResetTokenUser()
		return nil
	}
	return fmt.Errorf("unknown TblAuthToken edge %s", name)
}

// TblCartMutation represents an operation that mutates the TblCart nodes in the graph.
type TblCartMutation struct {
	config
	op                Op
	typ               string
	id                *string
	_Status           *tblcart.Status
	_Created_at       *time.Time
	_Updated_at       *time.Time
	_Deleted_at       *time.Time
	clearedFields     map[string]struct{}
	_Inventory        *string
	cleared_Inventory bool
	_User             *string
	cleared_User      bool
	done              bool
	oldValue          func(context.Context) (*TblCart, error)
	predicates        []predicate.TblCart
}

var _ ent.Mutation = (*TblCartMutation)(nil)

// tblcartOption allows management of the mutation configuration using functional options.
type tblcartOption func(*TblCartMutation)

// newTblCartMutation creates new mutation for the TblCart entity.
func newTblCartMutation(c config, op Op, opts ...tblcartOption) *TblCartMutation {
	m := &TblCartMutation{
		config:        c,
		op:            op,
		typ:           TypeTblCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblCartID sets the ID field of the mutation.
func withTblCartID(id string) tblcartOption {
	return func(m *TblCartMutation) {
		var (
			err   error
			once  sync.Once
			value *TblCart
		)
		m.oldValue = func(ctx context.Context) (*TblCart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblCart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblCart sets the old TblCart of the mutation.
func withTblCart(node *TblCart) tblcartOption {
	return func(m *TblCartMutation) {
		m.oldValue = func(context.Context) (*TblCart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblCartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblCartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblCart entities.
func (m *TblCartMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblCartMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblCartMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblCart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProductId sets the "ProductId" field.
func (m *TblCartMutation) SetProductId(s string) {
	m._Inventory = &s
}

// ProductId returns the value of the "ProductId" field in the mutation.
func (m *TblCartMutation) ProductId() (r string, exists bool) {
	v := m._Inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldProductId returns the old "ProductId" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldProductId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductId: %w", err)
	}
	return oldValue.ProductId, nil
}

// ClearProductId clears the value of the "ProductId" field.
func (m *TblCartMutation) ClearProductId() {
	m._Inventory = nil
	m.clearedFields[tblcart.FieldProductId] = struct{}{}
}

// ProductIdCleared returns if the "ProductId" field was cleared in this mutation.
func (m *TblCartMutation) ProductIdCleared() bool {
	_, ok := m.clearedFields[tblcart.FieldProductId]
	return ok
}

// ResetProductId resets all changes to the "ProductId" field.
func (m *TblCartMutation) ResetProductId() {
	m._Inventory = nil
	delete(m.clearedFields, tblcart.FieldProductId)
}

// SetUserId sets the "UserId" field.
func (m *TblCartMutation) SetUserId(s string) {
	m._User = &s
}

// UserId returns the value of the "UserId" field in the mutation.
func (m *TblCartMutation) UserId() (r string, exists bool) {
	v := m._User
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "UserId" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "UserId" field.
func (m *TblCartMutation) ClearUserId() {
	m._User = nil
	m.clearedFields[tblcart.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "UserId" field was cleared in this mutation.
func (m *TblCartMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[tblcart.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "UserId" field.
func (m *TblCartMutation) ResetUserId() {
	m._User = nil
	delete(m.clearedFields, tblcart.FieldUserId)
}

// SetStatus sets the "Status" field.
func (m *TblCartMutation) SetStatus(t tblcart.Status) {
	m._Status = &t
}

// Status returns the value of the "Status" field in the mutation.
func (m *TblCartMutation) Status() (r tblcart.Status, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldStatus(ctx context.Context) (v tblcart.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *TblCartMutation) ResetStatus() {
	m._Status = nil
}

// SetCreatedAt sets the "Created_at" field.
func (m *TblCartMutation) SetCreatedAt(t time.Time) {
	m._Created_at = &t
}

// CreatedAt returns the value of the "Created_at" field in the mutation.
func (m *TblCartMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._Created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "Created_at" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "Created_at" field.
func (m *TblCartMutation) ResetCreatedAt() {
	m._Created_at = nil
}

// SetUpdatedAt sets the "Updated_at" field.
func (m *TblCartMutation) SetUpdatedAt(t time.Time) {
	m._Updated_at = &t
}

// UpdatedAt returns the value of the "Updated_at" field in the mutation.
func (m *TblCartMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._Updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "Updated_at" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "Updated_at" field.
func (m *TblCartMutation) ResetUpdatedAt() {
	m._Updated_at = nil
}

// SetDeletedAt sets the "Deleted_at" field.
func (m *TblCartMutation) SetDeletedAt(t time.Time) {
	m._Deleted_at = &t
}

// DeletedAt returns the value of the "Deleted_at" field in the mutation.
func (m *TblCartMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._Deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "Deleted_at" field's value of the TblCart entity.
// If the TblCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblCartMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "Deleted_at" field.
func (m *TblCartMutation) ClearDeletedAt() {
	m._Deleted_at = nil
	m.clearedFields[tblcart.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "Deleted_at" field was cleared in this mutation.
func (m *TblCartMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tblcart.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "Deleted_at" field.
func (m *TblCartMutation) ResetDeletedAt() {
	m._Deleted_at = nil
	delete(m.clearedFields, tblcart.FieldDeletedAt)
}

// SetInventoryID sets the "Inventory" edge to the TblInventory entity by id.
func (m *TblCartMutation) SetInventoryID(id string) {
	m._Inventory = &id
}

// ClearInventory clears the "Inventory" edge to the TblInventory entity.
func (m *TblCartMutation) ClearInventory() {
	m.cleared_Inventory = true
	m.clearedFields[tblcart.FieldProductId] = struct{}{}
}

// InventoryCleared reports if the "Inventory" edge to the TblInventory entity was cleared.
func (m *TblCartMutation) InventoryCleared() bool {
	return m.ProductIdCleared() || m.cleared_Inventory
}

// InventoryID returns the "Inventory" edge ID in the mutation.
func (m *TblCartMutation) InventoryID() (id string, exists bool) {
	if m._Inventory != nil {
		return *m._Inventory, true
	}
	return
}

// InventoryIDs returns the "Inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryID instead. It exists only for internal usage by the builders.
func (m *TblCartMutation) InventoryIDs() (ids []string) {
	if id := m._Inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventory resets all changes to the "Inventory" edge.
func (m *TblCartMutation) ResetInventory() {
	m._Inventory = nil
	m.cleared_Inventory = false
}

// SetUserID sets the "User" edge to the TblUser entity by id.
func (m *TblCartMutation) SetUserID(id string) {
	m._User = &id
}

// ClearUser clears the "User" edge to the TblUser entity.
func (m *TblCartMutation) ClearUser() {
	m.cleared_User = true
	m.clearedFields[tblcart.FieldUserId] = struct{}{}
}

// UserCleared reports if the "User" edge to the TblUser entity was cleared.
func (m *TblCartMutation) UserCleared() bool {
	return m.UserIdCleared() || m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *TblCartMutation) UserID() (id string, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TblCartMutation) UserIDs() (ids []string) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *TblCartMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// Where appends a list predicates to the TblCartMutation builder.
func (m *TblCartMutation) Where(ps ...predicate.TblCart) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblCartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblCartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblCart, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblCartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblCartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblCart).
func (m *TblCartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblCartMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Inventory != nil {
		fields = append(fields, tblcart.FieldProductId)
	}
	if m._User != nil {
		fields = append(fields, tblcart.FieldUserId)
	}
	if m._Status != nil {
		fields = append(fields, tblcart.FieldStatus)
	}
	if m._Created_at != nil {
		fields = append(fields, tblcart.FieldCreatedAt)
	}
	if m._Updated_at != nil {
		fields = append(fields, tblcart.FieldUpdatedAt)
	}
	if m._Deleted_at != nil {
		fields = append(fields, tblcart.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblCartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblcart.FieldProductId:
		return m.ProductId()
	case tblcart.FieldUserId:
		return m.UserId()
	case tblcart.FieldStatus:
		return m.Status()
	case tblcart.FieldCreatedAt:
		return m.CreatedAt()
	case tblcart.FieldUpdatedAt:
		return m.UpdatedAt()
	case tblcart.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblCartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblcart.FieldProductId:
		return m.OldProductId(ctx)
	case tblcart.FieldUserId:
		return m.OldUserId(ctx)
	case tblcart.FieldStatus:
		return m.OldStatus(ctx)
	case tblcart.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tblcart.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tblcart.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TblCart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblCartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblcart.FieldProductId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductId(v)
		return nil
	case tblcart.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case tblcart.FieldStatus:
		v, ok := value.(tblcart.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tblcart.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tblcart.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tblcart.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TblCart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblCartMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblCartMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblCartMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TblCart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblCartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblcart.FieldProductId) {
		fields = append(fields, tblcart.FieldProductId)
	}
	if m.FieldCleared(tblcart.FieldUserId) {
		fields = append(fields, tblcart.FieldUserId)
	}
	if m.FieldCleared(tblcart.FieldDeletedAt) {
		fields = append(fields, tblcart.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblCartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblCartMutation) ClearField(name string) error {
	switch name {
	case tblcart.FieldProductId:
		m.ClearProductId()
		return nil
	case tblcart.FieldUserId:
		m.ClearUserId()
		return nil
	case tblcart.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblCart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblCartMutation) ResetField(name string) error {
	switch name {
	case tblcart.FieldProductId:
		m.ResetProductId()
		return nil
	case tblcart.FieldUserId:
		m.ResetUserId()
		return nil
	case tblcart.FieldStatus:
		m.ResetStatus()
		return nil
	case tblcart.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tblcart.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tblcart.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblCart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblCartMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Inventory != nil {
		edges = append(edges, tblcart.EdgeInventory)
	}
	if m._User != nil {
		edges = append(edges, tblcart.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblCartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblcart.EdgeInventory:
		if id := m._Inventory; id != nil {
			return []ent.Value{*id}
		}
	case tblcart.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblCartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblCartMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblCartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Inventory {
		edges = append(edges, tblcart.EdgeInventory)
	}
	if m.cleared_User {
		edges = append(edges, tblcart.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblCartMutation) EdgeCleared(name string) bool {
	switch name {
	case tblcart.EdgeInventory:
		return m.cleared_Inventory
	case tblcart.EdgeUser:
		return m.cleared_User
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblCartMutation) ClearEdge(name string) error {
	switch name {
	case tblcart.EdgeInventory:
		m.ClearInventory()
		return nil
	case tblcart.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TblCart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblCartMutation) ResetEdge(name string) error {
	switch name {
	case tblcart.EdgeInventory:
		m.ResetInventory()
		return nil
	case tblcart.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TblCart edge %s", name)
}

// TblInventoryMutation represents an operation that mutates the TblInventory nodes in the graph.
type TblInventoryMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	_Name                    *string
	_Description             *string
	_ImageLink               *string
	_Price                   *float32
	add_Price                *float32
	_Is_Active               *bool
	_Created_at              *time.Time
	_Updated_at              *time.Time
	_Deleted_at              *time.Time
	clearedFields            map[string]struct{}
	inventory                map[string]struct{}
	removedinventory         map[string]struct{}
	clearedinventory         bool
	_InventoryCart           map[string]struct{}
	removed_InventoryCart    map[string]struct{}
	cleared_InventoryCart    bool
	_InventoryPayment        map[string]struct{}
	removed_InventoryPayment map[string]struct{}
	cleared_InventoryPayment bool
	done                     bool
	oldValue                 func(context.Context) (*TblInventory, error)
	predicates               []predicate.TblInventory
}

var _ ent.Mutation = (*TblInventoryMutation)(nil)

// tblinventoryOption allows management of the mutation configuration using functional options.
type tblinventoryOption func(*TblInventoryMutation)

// newTblInventoryMutation creates new mutation for the TblInventory entity.
func newTblInventoryMutation(c config, op Op, opts ...tblinventoryOption) *TblInventoryMutation {
	m := &TblInventoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTblInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblInventoryID sets the ID field of the mutation.
func withTblInventoryID(id string) tblinventoryOption {
	return func(m *TblInventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *TblInventory
		)
		m.oldValue = func(ctx context.Context) (*TblInventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblInventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblInventory sets the old TblInventory of the mutation.
func withTblInventory(node *TblInventory) tblinventoryOption {
	return func(m *TblInventoryMutation) {
		m.oldValue = func(context.Context) (*TblInventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblInventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblInventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblInventory entities.
func (m *TblInventoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblInventoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblInventoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblInventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *TblInventoryMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TblInventoryMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TblInventoryMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *TblInventoryMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *TblInventoryMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *TblInventoryMutation) ResetDescription() {
	m._Description = nil
}

// SetImageLink sets the "ImageLink" field.
func (m *TblInventoryMutation) SetImageLink(s string) {
	m._ImageLink = &s
}

// ImageLink returns the value of the "ImageLink" field in the mutation.
func (m *TblInventoryMutation) ImageLink() (r string, exists bool) {
	v := m._ImageLink
	if v == nil {
		return
	}
	return *v, true
}

// OldImageLink returns the old "ImageLink" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldImageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageLink: %w", err)
	}
	return oldValue.ImageLink, nil
}

// ResetImageLink resets all changes to the "ImageLink" field.
func (m *TblInventoryMutation) ResetImageLink() {
	m._ImageLink = nil
}

// SetPrice sets the "Price" field.
func (m *TblInventoryMutation) SetPrice(f float32) {
	m._Price = &f
	m.add_Price = nil
}

// Price returns the value of the "Price" field in the mutation.
func (m *TblInventoryMutation) Price() (r float32, exists bool) {
	v := m._Price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "Price" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "Price" field.
func (m *TblInventoryMutation) AddPrice(f float32) {
	if m.add_Price != nil {
		*m.add_Price += f
	} else {
		m.add_Price = &f
	}
}

// AddedPrice returns the value that was added to the "Price" field in this mutation.
func (m *TblInventoryMutation) AddedPrice() (r float32, exists bool) {
	v := m.add_Price
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "Price" field.
func (m *TblInventoryMutation) ResetPrice() {
	m._Price = nil
	m.add_Price = nil
}

// SetIsActive sets the "Is_Active" field.
func (m *TblInventoryMutation) SetIsActive(b bool) {
	m._Is_Active = &b
}

// IsActive returns the value of the "Is_Active" field in the mutation.
func (m *TblInventoryMutation) IsActive() (r bool, exists bool) {
	v := m._Is_Active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "Is_Active" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "Is_Active" field.
func (m *TblInventoryMutation) ResetIsActive() {
	m._Is_Active = nil
}

// SetCreatedAt sets the "Created_at" field.
func (m *TblInventoryMutation) SetCreatedAt(t time.Time) {
	m._Created_at = &t
}

// CreatedAt returns the value of the "Created_at" field in the mutation.
func (m *TblInventoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._Created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "Created_at" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "Created_at" field.
func (m *TblInventoryMutation) ResetCreatedAt() {
	m._Created_at = nil
}

// SetUpdatedAt sets the "Updated_at" field.
func (m *TblInventoryMutation) SetUpdatedAt(t time.Time) {
	m._Updated_at = &t
}

// UpdatedAt returns the value of the "Updated_at" field in the mutation.
func (m *TblInventoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._Updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "Updated_at" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "Updated_at" field.
func (m *TblInventoryMutation) ResetUpdatedAt() {
	m._Updated_at = nil
}

// SetDeletedAt sets the "Deleted_at" field.
func (m *TblInventoryMutation) SetDeletedAt(t time.Time) {
	m._Deleted_at = &t
}

// DeletedAt returns the value of the "Deleted_at" field in the mutation.
func (m *TblInventoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._Deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "Deleted_at" field's value of the TblInventory entity.
// If the TblInventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "Deleted_at" field.
func (m *TblInventoryMutation) ClearDeletedAt() {
	m._Deleted_at = nil
	m.clearedFields[tblinventory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "Deleted_at" field was cleared in this mutation.
func (m *TblInventoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tblinventory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "Deleted_at" field.
func (m *TblInventoryMutation) ResetDeletedAt() {
	m._Deleted_at = nil
	delete(m.clearedFields, tblinventory.FieldDeletedAt)
}

// AddInventoryIDs adds the "inventory" edge to the TblInventoryTag entity by ids.
func (m *TblInventoryMutation) AddInventoryIDs(ids ...string) {
	if m.inventory == nil {
		m.inventory = make(map[string]struct{})
	}
	for i := range ids {
		m.inventory[ids[i]] = struct{}{}
	}
}

// ClearInventory clears the "inventory" edge to the TblInventoryTag entity.
func (m *TblInventoryMutation) ClearInventory() {
	m.clearedinventory = true
}

// InventoryCleared reports if the "inventory" edge to the TblInventoryTag entity was cleared.
func (m *TblInventoryMutation) InventoryCleared() bool {
	return m.clearedinventory
}

// RemoveInventoryIDs removes the "inventory" edge to the TblInventoryTag entity by IDs.
func (m *TblInventoryMutation) RemoveInventoryIDs(ids ...string) {
	if m.removedinventory == nil {
		m.removedinventory = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.inventory, ids[i])
		m.removedinventory[ids[i]] = struct{}{}
	}
}

// RemovedInventory returns the removed IDs of the "inventory" edge to the TblInventoryTag entity.
func (m *TblInventoryMutation) RemovedInventoryIDs() (ids []string) {
	for id := range m.removedinventory {
		ids = append(ids, id)
	}
	return
}

// InventoryIDs returns the "inventory" edge IDs in the mutation.
func (m *TblInventoryMutation) InventoryIDs() (ids []string) {
	for id := range m.inventory {
		ids = append(ids, id)
	}
	return
}

// ResetInventory resets all changes to the "inventory" edge.
func (m *TblInventoryMutation) ResetInventory() {
	m.inventory = nil
	m.clearedinventory = false
	m.removedinventory = nil
}

// AddInventoryCartIDs adds the "InventoryCart" edge to the TblCart entity by ids.
func (m *TblInventoryMutation) AddInventoryCartIDs(ids ...string) {
	if m._InventoryCart == nil {
		m._InventoryCart = make(map[string]struct{})
	}
	for i := range ids {
		m._InventoryCart[ids[i]] = struct{}{}
	}
}

// ClearInventoryCart clears the "InventoryCart" edge to the TblCart entity.
func (m *TblInventoryMutation) ClearInventoryCart() {
	m.cleared_InventoryCart = true
}

// InventoryCartCleared reports if the "InventoryCart" edge to the TblCart entity was cleared.
func (m *TblInventoryMutation) InventoryCartCleared() bool {
	return m.cleared_InventoryCart
}

// RemoveInventoryCartIDs removes the "InventoryCart" edge to the TblCart entity by IDs.
func (m *TblInventoryMutation) RemoveInventoryCartIDs(ids ...string) {
	if m.removed_InventoryCart == nil {
		m.removed_InventoryCart = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._InventoryCart, ids[i])
		m.removed_InventoryCart[ids[i]] = struct{}{}
	}
}

// RemovedInventoryCart returns the removed IDs of the "InventoryCart" edge to the TblCart entity.
func (m *TblInventoryMutation) RemovedInventoryCartIDs() (ids []string) {
	for id := range m.removed_InventoryCart {
		ids = append(ids, id)
	}
	return
}

// InventoryCartIDs returns the "InventoryCart" edge IDs in the mutation.
func (m *TblInventoryMutation) InventoryCartIDs() (ids []string) {
	for id := range m._InventoryCart {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryCart resets all changes to the "InventoryCart" edge.
func (m *TblInventoryMutation) ResetInventoryCart() {
	m._InventoryCart = nil
	m.cleared_InventoryCart = false
	m.removed_InventoryCart = nil
}

// AddInventoryPaymentIDs adds the "InventoryPayment" edge to the TblPayment entity by ids.
func (m *TblInventoryMutation) AddInventoryPaymentIDs(ids ...string) {
	if m._InventoryPayment == nil {
		m._InventoryPayment = make(map[string]struct{})
	}
	for i := range ids {
		m._InventoryPayment[ids[i]] = struct{}{}
	}
}

// ClearInventoryPayment clears the "InventoryPayment" edge to the TblPayment entity.
func (m *TblInventoryMutation) ClearInventoryPayment() {
	m.cleared_InventoryPayment = true
}

// InventoryPaymentCleared reports if the "InventoryPayment" edge to the TblPayment entity was cleared.
func (m *TblInventoryMutation) InventoryPaymentCleared() bool {
	return m.cleared_InventoryPayment
}

// RemoveInventoryPaymentIDs removes the "InventoryPayment" edge to the TblPayment entity by IDs.
func (m *TblInventoryMutation) RemoveInventoryPaymentIDs(ids ...string) {
	if m.removed_InventoryPayment == nil {
		m.removed_InventoryPayment = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._InventoryPayment, ids[i])
		m.removed_InventoryPayment[ids[i]] = struct{}{}
	}
}

// RemovedInventoryPayment returns the removed IDs of the "InventoryPayment" edge to the TblPayment entity.
func (m *TblInventoryMutation) RemovedInventoryPaymentIDs() (ids []string) {
	for id := range m.removed_InventoryPayment {
		ids = append(ids, id)
	}
	return
}

// InventoryPaymentIDs returns the "InventoryPayment" edge IDs in the mutation.
func (m *TblInventoryMutation) InventoryPaymentIDs() (ids []string) {
	for id := range m._InventoryPayment {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryPayment resets all changes to the "InventoryPayment" edge.
func (m *TblInventoryMutation) ResetInventoryPayment() {
	m._InventoryPayment = nil
	m.cleared_InventoryPayment = false
	m.removed_InventoryPayment = nil
}

// Where appends a list predicates to the TblInventoryMutation builder.
func (m *TblInventoryMutation) Where(ps ...predicate.TblInventory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblInventoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblInventoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblInventory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblInventoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblInventoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblInventory).
func (m *TblInventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblInventoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._Name != nil {
		fields = append(fields, tblinventory.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, tblinventory.FieldDescription)
	}
	if m._ImageLink != nil {
		fields = append(fields, tblinventory.FieldImageLink)
	}
	if m._Price != nil {
		fields = append(fields, tblinventory.FieldPrice)
	}
	if m._Is_Active != nil {
		fields = append(fields, tblinventory.FieldIsActive)
	}
	if m._Created_at != nil {
		fields = append(fields, tblinventory.FieldCreatedAt)
	}
	if m._Updated_at != nil {
		fields = append(fields, tblinventory.FieldUpdatedAt)
	}
	if m._Deleted_at != nil {
		fields = append(fields, tblinventory.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblInventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblinventory.FieldName:
		return m.Name()
	case tblinventory.FieldDescription:
		return m.Description()
	case tblinventory.FieldImageLink:
		return m.ImageLink()
	case tblinventory.FieldPrice:
		return m.Price()
	case tblinventory.FieldIsActive:
		return m.IsActive()
	case tblinventory.FieldCreatedAt:
		return m.CreatedAt()
	case tblinventory.FieldUpdatedAt:
		return m.UpdatedAt()
	case tblinventory.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblInventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblinventory.FieldName:
		return m.OldName(ctx)
	case tblinventory.FieldDescription:
		return m.OldDescription(ctx)
	case tblinventory.FieldImageLink:
		return m.OldImageLink(ctx)
	case tblinventory.FieldPrice:
		return m.OldPrice(ctx)
	case tblinventory.FieldIsActive:
		return m.OldIsActive(ctx)
	case tblinventory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tblinventory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tblinventory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TblInventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblInventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblinventory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tblinventory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tblinventory.FieldImageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageLink(v)
		return nil
	case tblinventory.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case tblinventory.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tblinventory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tblinventory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tblinventory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TblInventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblInventoryMutation) AddedFields() []string {
	var fields []string
	if m.add_Price != nil {
		fields = append(fields, tblinventory.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblInventoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tblinventory.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblInventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tblinventory.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown TblInventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblInventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblinventory.FieldDeletedAt) {
		fields = append(fields, tblinventory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblInventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblInventoryMutation) ClearField(name string) error {
	switch name {
	case tblinventory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblInventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblInventoryMutation) ResetField(name string) error {
	switch name {
	case tblinventory.FieldName:
		m.ResetName()
		return nil
	case tblinventory.FieldDescription:
		m.ResetDescription()
		return nil
	case tblinventory.FieldImageLink:
		m.ResetImageLink()
		return nil
	case tblinventory.FieldPrice:
		m.ResetPrice()
		return nil
	case tblinventory.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tblinventory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tblinventory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tblinventory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblInventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblInventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.inventory != nil {
		edges = append(edges, tblinventory.EdgeInventory)
	}
	if m._InventoryCart != nil {
		edges = append(edges, tblinventory.EdgeInventoryCart)
	}
	if m._InventoryPayment != nil {
		edges = append(edges, tblinventory.EdgeInventoryPayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblInventoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblinventory.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.inventory))
		for id := range m.inventory {
			ids = append(ids, id)
		}
		return ids
	case tblinventory.EdgeInventoryCart:
		ids := make([]ent.Value, 0, len(m._InventoryCart))
		for id := range m._InventoryCart {
			ids = append(ids, id)
		}
		return ids
	case tblinventory.EdgeInventoryPayment:
		ids := make([]ent.Value, 0, len(m._InventoryPayment))
		for id := range m._InventoryPayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblInventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinventory != nil {
		edges = append(edges, tblinventory.EdgeInventory)
	}
	if m.removed_InventoryCart != nil {
		edges = append(edges, tblinventory.EdgeInventoryCart)
	}
	if m.removed_InventoryPayment != nil {
		edges = append(edges, tblinventory.EdgeInventoryPayment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblInventoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tblinventory.EdgeInventory:
		ids := make([]ent.Value, 0, len(m.removedinventory))
		for id := range m.removedinventory {
			ids = append(ids, id)
		}
		return ids
	case tblinventory.EdgeInventoryCart:
		ids := make([]ent.Value, 0, len(m.removed_InventoryCart))
		for id := range m.removed_InventoryCart {
			ids = append(ids, id)
		}
		return ids
	case tblinventory.EdgeInventoryPayment:
		ids := make([]ent.Value, 0, len(m.removed_InventoryPayment))
		for id := range m.removed_InventoryPayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblInventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedinventory {
		edges = append(edges, tblinventory.EdgeInventory)
	}
	if m.cleared_InventoryCart {
		edges = append(edges, tblinventory.EdgeInventoryCart)
	}
	if m.cleared_InventoryPayment {
		edges = append(edges, tblinventory.EdgeInventoryPayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblInventoryMutation) EdgeCleared(name string) bool {
	switch name {
	case tblinventory.EdgeInventory:
		return m.clearedinventory
	case tblinventory.EdgeInventoryCart:
		return m.cleared_InventoryCart
	case tblinventory.EdgeInventoryPayment:
		return m.cleared_InventoryPayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblInventoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TblInventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblInventoryMutation) ResetEdge(name string) error {
	switch name {
	case tblinventory.EdgeInventory:
		m.ResetInventory()
		return nil
	case tblinventory.EdgeInventoryCart:
		m.ResetInventoryCart()
		return nil
	case tblinventory.EdgeInventoryPayment:
		m.ResetInventoryPayment()
		return nil
	}
	return fmt.Errorf("unknown TblInventory edge %s", name)
}

// TblInventoryTagMutation represents an operation that mutates the TblInventoryTag nodes in the graph.
type TblInventoryTagMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	_InventoryId        *string
	_TagId              *string
	_Created_at         *time.Time
	_Updated_at         *time.Time
	_Deleted_at         *time.Time
	clearedFields       map[string]struct{}
	tag_Id              *string
	clearedtag_Id       bool
	inventory_Id        *string
	clearedinventory_Id bool
	done                bool
	oldValue            func(context.Context) (*TblInventoryTag, error)
	predicates          []predicate.TblInventoryTag
}

var _ ent.Mutation = (*TblInventoryTagMutation)(nil)

// tblinventorytagOption allows management of the mutation configuration using functional options.
type tblinventorytagOption func(*TblInventoryTagMutation)

// newTblInventoryTagMutation creates new mutation for the TblInventoryTag entity.
func newTblInventoryTagMutation(c config, op Op, opts ...tblinventorytagOption) *TblInventoryTagMutation {
	m := &TblInventoryTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTblInventoryTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblInventoryTagID sets the ID field of the mutation.
func withTblInventoryTagID(id string) tblinventorytagOption {
	return func(m *TblInventoryTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TblInventoryTag
		)
		m.oldValue = func(ctx context.Context) (*TblInventoryTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblInventoryTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblInventoryTag sets the old TblInventoryTag of the mutation.
func withTblInventoryTag(node *TblInventoryTag) tblinventorytagOption {
	return func(m *TblInventoryTagMutation) {
		m.oldValue = func(context.Context) (*TblInventoryTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblInventoryTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblInventoryTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblInventoryTag entities.
func (m *TblInventoryTagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblInventoryTagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblInventoryTagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblInventoryTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInventoryId sets the "InventoryId" field.
func (m *TblInventoryTagMutation) SetInventoryId(s string) {
	m._InventoryId = &s
}

// InventoryId returns the value of the "InventoryId" field in the mutation.
func (m *TblInventoryTagMutation) InventoryId() (r string, exists bool) {
	v := m._InventoryId
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryId returns the old "InventoryId" field's value of the TblInventoryTag entity.
// If the TblInventoryTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryTagMutation) OldInventoryId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventoryId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryId: %w", err)
	}
	return oldValue.InventoryId, nil
}

// ClearInventoryId clears the value of the "InventoryId" field.
func (m *TblInventoryTagMutation) ClearInventoryId() {
	m._InventoryId = nil
	m.clearedFields[tblinventorytag.FieldInventoryId] = struct{}{}
}

// InventoryIdCleared returns if the "InventoryId" field was cleared in this mutation.
func (m *TblInventoryTagMutation) InventoryIdCleared() bool {
	_, ok := m.clearedFields[tblinventorytag.FieldInventoryId]
	return ok
}

// ResetInventoryId resets all changes to the "InventoryId" field.
func (m *TblInventoryTagMutation) ResetInventoryId() {
	m._InventoryId = nil
	delete(m.clearedFields, tblinventorytag.FieldInventoryId)
}

// SetTagId sets the "TagId" field.
func (m *TblInventoryTagMutation) SetTagId(s string) {
	m._TagId = &s
}

// TagId returns the value of the "TagId" field in the mutation.
func (m *TblInventoryTagMutation) TagId() (r string, exists bool) {
	v := m._TagId
	if v == nil {
		return
	}
	return *v, true
}

// OldTagId returns the old "TagId" field's value of the TblInventoryTag entity.
// If the TblInventoryTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryTagMutation) OldTagId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagId: %w", err)
	}
	return oldValue.TagId, nil
}

// ClearTagId clears the value of the "TagId" field.
func (m *TblInventoryTagMutation) ClearTagId() {
	m._TagId = nil
	m.clearedFields[tblinventorytag.FieldTagId] = struct{}{}
}

// TagIdCleared returns if the "TagId" field was cleared in this mutation.
func (m *TblInventoryTagMutation) TagIdCleared() bool {
	_, ok := m.clearedFields[tblinventorytag.FieldTagId]
	return ok
}

// ResetTagId resets all changes to the "TagId" field.
func (m *TblInventoryTagMutation) ResetTagId() {
	m._TagId = nil
	delete(m.clearedFields, tblinventorytag.FieldTagId)
}

// SetCreatedAt sets the "Created_at" field.
func (m *TblInventoryTagMutation) SetCreatedAt(t time.Time) {
	m._Created_at = &t
}

// CreatedAt returns the value of the "Created_at" field in the mutation.
func (m *TblInventoryTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._Created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "Created_at" field's value of the TblInventoryTag entity.
// If the TblInventoryTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "Created_at" field.
func (m *TblInventoryTagMutation) ResetCreatedAt() {
	m._Created_at = nil
}

// SetUpdatedAt sets the "Updated_at" field.
func (m *TblInventoryTagMutation) SetUpdatedAt(t time.Time) {
	m._Updated_at = &t
}

// UpdatedAt returns the value of the "Updated_at" field in the mutation.
func (m *TblInventoryTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._Updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "Updated_at" field's value of the TblInventoryTag entity.
// If the TblInventoryTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "Updated_at" field.
func (m *TblInventoryTagMutation) ResetUpdatedAt() {
	m._Updated_at = nil
}

// SetDeletedAt sets the "Deleted_at" field.
func (m *TblInventoryTagMutation) SetDeletedAt(t time.Time) {
	m._Deleted_at = &t
}

// DeletedAt returns the value of the "Deleted_at" field in the mutation.
func (m *TblInventoryTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._Deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "Deleted_at" field's value of the TblInventoryTag entity.
// If the TblInventoryTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblInventoryTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ResetDeletedAt resets all changes to the "Deleted_at" field.
func (m *TblInventoryTagMutation) ResetDeletedAt() {
	m._Deleted_at = nil
}

// SetTagIDID sets the "tag_Id" edge to the TblTag entity by id.
func (m *TblInventoryTagMutation) SetTagIDID(id string) {
	m.tag_Id = &id
}

// ClearTagID clears the "tag_Id" edge to the TblTag entity.
func (m *TblInventoryTagMutation) ClearTagID() {
	m.clearedtag_Id = true
}

// TagIDCleared reports if the "tag_Id" edge to the TblTag entity was cleared.
func (m *TblInventoryTagMutation) TagIDCleared() bool {
	return m.clearedtag_Id
}

// TagIDID returns the "tag_Id" edge ID in the mutation.
func (m *TblInventoryTagMutation) TagIDID() (id string, exists bool) {
	if m.tag_Id != nil {
		return *m.tag_Id, true
	}
	return
}

// TagIDIDs returns the "tag_Id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagIDID instead. It exists only for internal usage by the builders.
func (m *TblInventoryTagMutation) TagIDIDs() (ids []string) {
	if id := m.tag_Id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTagID resets all changes to the "tag_Id" edge.
func (m *TblInventoryTagMutation) ResetTagID() {
	m.tag_Id = nil
	m.clearedtag_Id = false
}

// SetInventoryIDID sets the "inventory_Id" edge to the TblInventory entity by id.
func (m *TblInventoryTagMutation) SetInventoryIDID(id string) {
	m.inventory_Id = &id
}

// ClearInventoryID clears the "inventory_Id" edge to the TblInventory entity.
func (m *TblInventoryTagMutation) ClearInventoryID() {
	m.clearedinventory_Id = true
}

// InventoryIDCleared reports if the "inventory_Id" edge to the TblInventory entity was cleared.
func (m *TblInventoryTagMutation) InventoryIDCleared() bool {
	return m.clearedinventory_Id
}

// InventoryIDID returns the "inventory_Id" edge ID in the mutation.
func (m *TblInventoryTagMutation) InventoryIDID() (id string, exists bool) {
	if m.inventory_Id != nil {
		return *m.inventory_Id, true
	}
	return
}

// InventoryIDIDs returns the "inventory_Id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryIDID instead. It exists only for internal usage by the builders.
func (m *TblInventoryTagMutation) InventoryIDIDs() (ids []string) {
	if id := m.inventory_Id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryID resets all changes to the "inventory_Id" edge.
func (m *TblInventoryTagMutation) ResetInventoryID() {
	m.inventory_Id = nil
	m.clearedinventory_Id = false
}

// Where appends a list predicates to the TblInventoryTagMutation builder.
func (m *TblInventoryTagMutation) Where(ps ...predicate.TblInventoryTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblInventoryTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblInventoryTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblInventoryTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblInventoryTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblInventoryTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblInventoryTag).
func (m *TblInventoryTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblInventoryTagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._InventoryId != nil {
		fields = append(fields, tblinventorytag.FieldInventoryId)
	}
	if m._TagId != nil {
		fields = append(fields, tblinventorytag.FieldTagId)
	}
	if m._Created_at != nil {
		fields = append(fields, tblinventorytag.FieldCreatedAt)
	}
	if m._Updated_at != nil {
		fields = append(fields, tblinventorytag.FieldUpdatedAt)
	}
	if m._Deleted_at != nil {
		fields = append(fields, tblinventorytag.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblInventoryTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblinventorytag.FieldInventoryId:
		return m.InventoryId()
	case tblinventorytag.FieldTagId:
		return m.TagId()
	case tblinventorytag.FieldCreatedAt:
		return m.CreatedAt()
	case tblinventorytag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tblinventorytag.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblInventoryTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblinventorytag.FieldInventoryId:
		return m.OldInventoryId(ctx)
	case tblinventorytag.FieldTagId:
		return m.OldTagId(ctx)
	case tblinventorytag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tblinventorytag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tblinventorytag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TblInventoryTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblInventoryTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblinventorytag.FieldInventoryId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryId(v)
		return nil
	case tblinventorytag.FieldTagId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagId(v)
		return nil
	case tblinventorytag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tblinventorytag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tblinventorytag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TblInventoryTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblInventoryTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblInventoryTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblInventoryTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TblInventoryTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblInventoryTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblinventorytag.FieldInventoryId) {
		fields = append(fields, tblinventorytag.FieldInventoryId)
	}
	if m.FieldCleared(tblinventorytag.FieldTagId) {
		fields = append(fields, tblinventorytag.FieldTagId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblInventoryTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblInventoryTagMutation) ClearField(name string) error {
	switch name {
	case tblinventorytag.FieldInventoryId:
		m.ClearInventoryId()
		return nil
	case tblinventorytag.FieldTagId:
		m.ClearTagId()
		return nil
	}
	return fmt.Errorf("unknown TblInventoryTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblInventoryTagMutation) ResetField(name string) error {
	switch name {
	case tblinventorytag.FieldInventoryId:
		m.ResetInventoryId()
		return nil
	case tblinventorytag.FieldTagId:
		m.ResetTagId()
		return nil
	case tblinventorytag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tblinventorytag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tblinventorytag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblInventoryTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblInventoryTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tag_Id != nil {
		edges = append(edges, tblinventorytag.EdgeTagID)
	}
	if m.inventory_Id != nil {
		edges = append(edges, tblinventorytag.EdgeInventoryID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblInventoryTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblinventorytag.EdgeTagID:
		if id := m.tag_Id; id != nil {
			return []ent.Value{*id}
		}
	case tblinventorytag.EdgeInventoryID:
		if id := m.inventory_Id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblInventoryTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblInventoryTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblInventoryTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtag_Id {
		edges = append(edges, tblinventorytag.EdgeTagID)
	}
	if m.clearedinventory_Id {
		edges = append(edges, tblinventorytag.EdgeInventoryID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblInventoryTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tblinventorytag.EdgeTagID:
		return m.clearedtag_Id
	case tblinventorytag.EdgeInventoryID:
		return m.clearedinventory_Id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblInventoryTagMutation) ClearEdge(name string) error {
	switch name {
	case tblinventorytag.EdgeTagID:
		m.ClearTagID()
		return nil
	case tblinventorytag.EdgeInventoryID:
		m.ClearInventoryID()
		return nil
	}
	return fmt.Errorf("unknown TblInventoryTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblInventoryTagMutation) ResetEdge(name string) error {
	switch name {
	case tblinventorytag.EdgeTagID:
		m.ResetTagID()
		return nil
	case tblinventorytag.EdgeInventoryID:
		m.ResetInventoryID()
		return nil
	}
	return fmt.Errorf("unknown TblInventoryTag edge %s", name)
}

// TblPaymentMutation represents an operation that mutates the TblPayment nodes in the graph.
type TblPaymentMutation struct {
	config
	op                Op
	typ               string
	id                *string
	_Status           *string
	_RazorpayOrderId  *string
	_Amount           *float32
	add_Amount        *float32
	_Created_at       *time.Time
	_Updated_at       *time.Time
	_Deleted_at       *time.Time
	clearedFields     map[string]struct{}
	_Inventory        *string
	cleared_Inventory bool
	_User             *string
	cleared_User      bool
	done              bool
	oldValue          func(context.Context) (*TblPayment, error)
	predicates        []predicate.TblPayment
}

var _ ent.Mutation = (*TblPaymentMutation)(nil)

// tblpaymentOption allows management of the mutation configuration using functional options.
type tblpaymentOption func(*TblPaymentMutation)

// newTblPaymentMutation creates new mutation for the TblPayment entity.
func newTblPaymentMutation(c config, op Op, opts ...tblpaymentOption) *TblPaymentMutation {
	m := &TblPaymentMutation{
		config:        c,
		op:            op,
		typ:           TypeTblPayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblPaymentID sets the ID field of the mutation.
func withTblPaymentID(id string) tblpaymentOption {
	return func(m *TblPaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *TblPayment
		)
		m.oldValue = func(ctx context.Context) (*TblPayment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblPayment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblPayment sets the old TblPayment of the mutation.
func withTblPayment(node *TblPayment) tblpaymentOption {
	return func(m *TblPaymentMutation) {
		m.oldValue = func(context.Context) (*TblPayment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblPaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblPaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblPayment entities.
func (m *TblPaymentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblPaymentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblPaymentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblPayment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInventoryId sets the "InventoryId" field.
func (m *TblPaymentMutation) SetInventoryId(s string) {
	m._Inventory = &s
}

// InventoryId returns the value of the "InventoryId" field in the mutation.
func (m *TblPaymentMutation) InventoryId() (r string, exists bool) {
	v := m._Inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventoryId returns the old "InventoryId" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldInventoryId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventoryId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventoryId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventoryId: %w", err)
	}
	return oldValue.InventoryId, nil
}

// ClearInventoryId clears the value of the "InventoryId" field.
func (m *TblPaymentMutation) ClearInventoryId() {
	m._Inventory = nil
	m.clearedFields[tblpayment.FieldInventoryId] = struct{}{}
}

// InventoryIdCleared returns if the "InventoryId" field was cleared in this mutation.
func (m *TblPaymentMutation) InventoryIdCleared() bool {
	_, ok := m.clearedFields[tblpayment.FieldInventoryId]
	return ok
}

// ResetInventoryId resets all changes to the "InventoryId" field.
func (m *TblPaymentMutation) ResetInventoryId() {
	m._Inventory = nil
	delete(m.clearedFields, tblpayment.FieldInventoryId)
}

// SetUserId sets the "UserId" field.
func (m *TblPaymentMutation) SetUserId(s string) {
	m._User = &s
}

// UserId returns the value of the "UserId" field in the mutation.
func (m *TblPaymentMutation) UserId() (r string, exists bool) {
	v := m._User
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "UserId" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "UserId" field.
func (m *TblPaymentMutation) ClearUserId() {
	m._User = nil
	m.clearedFields[tblpayment.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "UserId" field was cleared in this mutation.
func (m *TblPaymentMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[tblpayment.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "UserId" field.
func (m *TblPaymentMutation) ResetUserId() {
	m._User = nil
	delete(m.clearedFields, tblpayment.FieldUserId)
}

// SetStatus sets the "Status" field.
func (m *TblPaymentMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *TblPaymentMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "Status" field.
func (m *TblPaymentMutation) ResetStatus() {
	m._Status = nil
}

// SetRazorpayOrderId sets the "RazorpayOrderId" field.
func (m *TblPaymentMutation) SetRazorpayOrderId(s string) {
	m._RazorpayOrderId = &s
}

// RazorpayOrderId returns the value of the "RazorpayOrderId" field in the mutation.
func (m *TblPaymentMutation) RazorpayOrderId() (r string, exists bool) {
	v := m._RazorpayOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldRazorpayOrderId returns the old "RazorpayOrderId" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldRazorpayOrderId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRazorpayOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRazorpayOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRazorpayOrderId: %w", err)
	}
	return oldValue.RazorpayOrderId, nil
}

// ResetRazorpayOrderId resets all changes to the "RazorpayOrderId" field.
func (m *TblPaymentMutation) ResetRazorpayOrderId() {
	m._RazorpayOrderId = nil
}

// SetAmount sets the "Amount" field.
func (m *TblPaymentMutation) SetAmount(f float32) {
	m._Amount = &f
	m.add_Amount = nil
}

// Amount returns the value of the "Amount" field in the mutation.
func (m *TblPaymentMutation) Amount() (r float32, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "Amount" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldAmount(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "Amount" field.
func (m *TblPaymentMutation) AddAmount(f float32) {
	if m.add_Amount != nil {
		*m.add_Amount += f
	} else {
		m.add_Amount = &f
	}
}

// AddedAmount returns the value that was added to the "Amount" field in this mutation.
func (m *TblPaymentMutation) AddedAmount() (r float32, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "Amount" field.
func (m *TblPaymentMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
}

// SetCreatedAt sets the "Created_at" field.
func (m *TblPaymentMutation) SetCreatedAt(t time.Time) {
	m._Created_at = &t
}

// CreatedAt returns the value of the "Created_at" field in the mutation.
func (m *TblPaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._Created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "Created_at" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "Created_at" field.
func (m *TblPaymentMutation) ResetCreatedAt() {
	m._Created_at = nil
}

// SetUpdatedAt sets the "Updated_at" field.
func (m *TblPaymentMutation) SetUpdatedAt(t time.Time) {
	m._Updated_at = &t
}

// UpdatedAt returns the value of the "Updated_at" field in the mutation.
func (m *TblPaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._Updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "Updated_at" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "Updated_at" field.
func (m *TblPaymentMutation) ResetUpdatedAt() {
	m._Updated_at = nil
}

// SetDeletedAt sets the "Deleted_at" field.
func (m *TblPaymentMutation) SetDeletedAt(t time.Time) {
	m._Deleted_at = &t
}

// DeletedAt returns the value of the "Deleted_at" field in the mutation.
func (m *TblPaymentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._Deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "Deleted_at" field's value of the TblPayment entity.
// If the TblPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblPaymentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "Deleted_at" field.
func (m *TblPaymentMutation) ClearDeletedAt() {
	m._Deleted_at = nil
	m.clearedFields[tblpayment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "Deleted_at" field was cleared in this mutation.
func (m *TblPaymentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tblpayment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "Deleted_at" field.
func (m *TblPaymentMutation) ResetDeletedAt() {
	m._Deleted_at = nil
	delete(m.clearedFields, tblpayment.FieldDeletedAt)
}

// SetInventoryID sets the "Inventory" edge to the TblInventory entity by id.
func (m *TblPaymentMutation) SetInventoryID(id string) {
	m._Inventory = &id
}

// ClearInventory clears the "Inventory" edge to the TblInventory entity.
func (m *TblPaymentMutation) ClearInventory() {
	m.cleared_Inventory = true
	m.clearedFields[tblpayment.FieldInventoryId] = struct{}{}
}

// InventoryCleared reports if the "Inventory" edge to the TblInventory entity was cleared.
func (m *TblPaymentMutation) InventoryCleared() bool {
	return m.InventoryIdCleared() || m.cleared_Inventory
}

// InventoryID returns the "Inventory" edge ID in the mutation.
func (m *TblPaymentMutation) InventoryID() (id string, exists bool) {
	if m._Inventory != nil {
		return *m._Inventory, true
	}
	return
}

// InventoryIDs returns the "Inventory" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryID instead. It exists only for internal usage by the builders.
func (m *TblPaymentMutation) InventoryIDs() (ids []string) {
	if id := m._Inventory; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventory resets all changes to the "Inventory" edge.
func (m *TblPaymentMutation) ResetInventory() {
	m._Inventory = nil
	m.cleared_Inventory = false
}

// SetUserID sets the "User" edge to the TblUser entity by id.
func (m *TblPaymentMutation) SetUserID(id string) {
	m._User = &id
}

// ClearUser clears the "User" edge to the TblUser entity.
func (m *TblPaymentMutation) ClearUser() {
	m.cleared_User = true
	m.clearedFields[tblpayment.FieldUserId] = struct{}{}
}

// UserCleared reports if the "User" edge to the TblUser entity was cleared.
func (m *TblPaymentMutation) UserCleared() bool {
	return m.UserIdCleared() || m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *TblPaymentMutation) UserID() (id string, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TblPaymentMutation) UserIDs() (ids []string) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *TblPaymentMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// Where appends a list predicates to the TblPaymentMutation builder.
func (m *TblPaymentMutation) Where(ps ...predicate.TblPayment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblPaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblPaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblPayment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblPaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblPaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblPayment).
func (m *TblPaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblPaymentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._Inventory != nil {
		fields = append(fields, tblpayment.FieldInventoryId)
	}
	if m._User != nil {
		fields = append(fields, tblpayment.FieldUserId)
	}
	if m._Status != nil {
		fields = append(fields, tblpayment.FieldStatus)
	}
	if m._RazorpayOrderId != nil {
		fields = append(fields, tblpayment.FieldRazorpayOrderId)
	}
	if m._Amount != nil {
		fields = append(fields, tblpayment.FieldAmount)
	}
	if m._Created_at != nil {
		fields = append(fields, tblpayment.FieldCreatedAt)
	}
	if m._Updated_at != nil {
		fields = append(fields, tblpayment.FieldUpdatedAt)
	}
	if m._Deleted_at != nil {
		fields = append(fields, tblpayment.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblPaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tblpayment.FieldInventoryId:
		return m.InventoryId()
	case tblpayment.FieldUserId:
		return m.UserId()
	case tblpayment.FieldStatus:
		return m.Status()
	case tblpayment.FieldRazorpayOrderId:
		return m.RazorpayOrderId()
	case tblpayment.FieldAmount:
		return m.Amount()
	case tblpayment.FieldCreatedAt:
		return m.CreatedAt()
	case tblpayment.FieldUpdatedAt:
		return m.UpdatedAt()
	case tblpayment.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblPaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tblpayment.FieldInventoryId:
		return m.OldInventoryId(ctx)
	case tblpayment.FieldUserId:
		return m.OldUserId(ctx)
	case tblpayment.FieldStatus:
		return m.OldStatus(ctx)
	case tblpayment.FieldRazorpayOrderId:
		return m.OldRazorpayOrderId(ctx)
	case tblpayment.FieldAmount:
		return m.OldAmount(ctx)
	case tblpayment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tblpayment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tblpayment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TblPayment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblPaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tblpayment.FieldInventoryId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventoryId(v)
		return nil
	case tblpayment.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case tblpayment.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tblpayment.FieldRazorpayOrderId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRazorpayOrderId(v)
		return nil
	case tblpayment.FieldAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case tblpayment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tblpayment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tblpayment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TblPayment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblPaymentMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, tblpayment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblPaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tblpayment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblPaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tblpayment.FieldAmount:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TblPayment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblPaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tblpayment.FieldInventoryId) {
		fields = append(fields, tblpayment.FieldInventoryId)
	}
	if m.FieldCleared(tblpayment.FieldUserId) {
		fields = append(fields, tblpayment.FieldUserId)
	}
	if m.FieldCleared(tblpayment.FieldDeletedAt) {
		fields = append(fields, tblpayment.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblPaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblPaymentMutation) ClearField(name string) error {
	switch name {
	case tblpayment.FieldInventoryId:
		m.ClearInventoryId()
		return nil
	case tblpayment.FieldUserId:
		m.ClearUserId()
		return nil
	case tblpayment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblPayment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblPaymentMutation) ResetField(name string) error {
	switch name {
	case tblpayment.FieldInventoryId:
		m.ResetInventoryId()
		return nil
	case tblpayment.FieldUserId:
		m.ResetUserId()
		return nil
	case tblpayment.FieldStatus:
		m.ResetStatus()
		return nil
	case tblpayment.FieldRazorpayOrderId:
		m.ResetRazorpayOrderId()
		return nil
	case tblpayment.FieldAmount:
		m.ResetAmount()
		return nil
	case tblpayment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tblpayment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tblpayment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblPayment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblPaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Inventory != nil {
		edges = append(edges, tblpayment.EdgeInventory)
	}
	if m._User != nil {
		edges = append(edges, tblpayment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblPaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tblpayment.EdgeInventory:
		if id := m._Inventory; id != nil {
			return []ent.Value{*id}
		}
	case tblpayment.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblPaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblPaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblPaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Inventory {
		edges = append(edges, tblpayment.EdgeInventory)
	}
	if m.cleared_User {
		edges = append(edges, tblpayment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblPaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case tblpayment.EdgeInventory:
		return m.cleared_Inventory
	case tblpayment.EdgeUser:
		return m.cleared_User
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblPaymentMutation) ClearEdge(name string) error {
	switch name {
	case tblpayment.EdgeInventory:
		m.ClearInventory()
		return nil
	case tblpayment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TblPayment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblPaymentMutation) ResetEdge(name string) error {
	switch name {
	case tblpayment.EdgeInventory:
		m.ResetInventory()
		return nil
	case tblpayment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TblPayment edge %s", name)
}

// TblTagMutation represents an operation that mutates the TblTag nodes in the graph.
type TblTagMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_Name         *string
	_Description  *string
	_Is_Active    *bool
	_Created_at   *time.Time
	_Updated_at   *time.Time
	_Deleted_at   *time.Time
	clearedFields map[string]struct{}
	tag           map[string]struct{}
	removedtag    map[string]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*TblTag, error)
	predicates    []predicate.TblTag
}

var _ ent.Mutation = (*TblTagMutation)(nil)

// tbltagOption allows management of the mutation configuration using functional options.
type tbltagOption func(*TblTagMutation)

// newTblTagMutation creates new mutation for the TblTag entity.
func newTblTagMutation(c config, op Op, opts ...tbltagOption) *TblTagMutation {
	m := &TblTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTblTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblTagID sets the ID field of the mutation.
func withTblTagID(id string) tbltagOption {
	return func(m *TblTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TblTag
		)
		m.oldValue = func(ctx context.Context) (*TblTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblTag sets the old TblTag of the mutation.
func withTblTag(node *TblTag) tbltagOption {
	return func(m *TblTagMutation) {
		m.oldValue = func(context.Context) (*TblTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblTag entities.
func (m *TblTagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblTagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblTagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *TblTagMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TblTagMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TblTagMutation) ResetName() {
	m._Name = nil
}

// SetDescription sets the "Description" field.
func (m *TblTagMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *TblTagMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "Description" field.
func (m *TblTagMutation) ResetDescription() {
	m._Description = nil
}

// SetIsActive sets the "Is_Active" field.
func (m *TblTagMutation) SetIsActive(b bool) {
	m._Is_Active = &b
}

// IsActive returns the value of the "Is_Active" field in the mutation.
func (m *TblTagMutation) IsActive() (r bool, exists bool) {
	v := m._Is_Active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "Is_Active" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "Is_Active" field.
func (m *TblTagMutation) ResetIsActive() {
	m._Is_Active = nil
}

// SetCreatedAt sets the "Created_at" field.
func (m *TblTagMutation) SetCreatedAt(t time.Time) {
	m._Created_at = &t
}

// CreatedAt returns the value of the "Created_at" field in the mutation.
func (m *TblTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._Created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "Created_at" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "Created_at" field.
func (m *TblTagMutation) ResetCreatedAt() {
	m._Created_at = nil
}

// SetUpdatedAt sets the "Updated_at" field.
func (m *TblTagMutation) SetUpdatedAt(t time.Time) {
	m._Updated_at = &t
}

// UpdatedAt returns the value of the "Updated_at" field in the mutation.
func (m *TblTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._Updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "Updated_at" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "Updated_at" field.
func (m *TblTagMutation) ResetUpdatedAt() {
	m._Updated_at = nil
}

// SetDeletedAt sets the "Deleted_at" field.
func (m *TblTagMutation) SetDeletedAt(t time.Time) {
	m._Deleted_at = &t
}

// DeletedAt returns the value of the "Deleted_at" field in the mutation.
func (m *TblTagMutation) DeletedAt() (r time.Time, exists bool) {
	v := m._Deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "Deleted_at" field's value of the TblTag entity.
// If the TblTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblTagMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "Deleted_at" field.
func (m *TblTagMutation) ClearDeletedAt() {
	m._Deleted_at = nil
	m.clearedFields[tbltag.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "Deleted_at" field was cleared in this mutation.
func (m *TblTagMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tbltag.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "Deleted_at" field.
func (m *TblTagMutation) ResetDeletedAt() {
	m._Deleted_at = nil
	delete(m.clearedFields, tbltag.FieldDeletedAt)
}

// AddTagIDs adds the "tag" edge to the TblInventoryTag entity by ids.
func (m *TblTagMutation) AddTagIDs(ids ...string) {
	if m.tag == nil {
		m.tag = make(map[string]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the TblInventoryTag entity.
func (m *TblTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the TblInventoryTag entity was cleared.
func (m *TblTagMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the TblInventoryTag entity by IDs.
func (m *TblTagMutation) RemoveTagIDs(ids ...string) {
	if m.removedtag == nil {
		m.removedtag = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the TblInventoryTag entity.
func (m *TblTagMutation) RemovedTagIDs() (ids []string) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *TblTagMutation) TagIDs() (ids []string) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TblTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Where appends a list predicates to the TblTagMutation builder.
func (m *TblTagMutation) Where(ps ...predicate.TblTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblTag).
func (m *TblTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblTagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Name != nil {
		fields = append(fields, tbltag.FieldName)
	}
	if m._Description != nil {
		fields = append(fields, tbltag.FieldDescription)
	}
	if m._Is_Active != nil {
		fields = append(fields, tbltag.FieldIsActive)
	}
	if m._Created_at != nil {
		fields = append(fields, tbltag.FieldCreatedAt)
	}
	if m._Updated_at != nil {
		fields = append(fields, tbltag.FieldUpdatedAt)
	}
	if m._Deleted_at != nil {
		fields = append(fields, tbltag.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tbltag.FieldName:
		return m.Name()
	case tbltag.FieldDescription:
		return m.Description()
	case tbltag.FieldIsActive:
		return m.IsActive()
	case tbltag.FieldCreatedAt:
		return m.CreatedAt()
	case tbltag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tbltag.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tbltag.FieldName:
		return m.OldName(ctx)
	case tbltag.FieldDescription:
		return m.OldDescription(ctx)
	case tbltag.FieldIsActive:
		return m.OldIsActive(ctx)
	case tbltag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tbltag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tbltag.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TblTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tbltag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tbltag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tbltag.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tbltag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tbltag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tbltag.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TblTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TblTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tbltag.FieldDeletedAt) {
		fields = append(fields, tbltag.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblTagMutation) ClearField(name string) error {
	switch name {
	case tbltag.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblTagMutation) ResetField(name string) error {
	switch name {
	case tbltag.FieldName:
		m.ResetName()
		return nil
	case tbltag.FieldDescription:
		m.ResetDescription()
		return nil
	case tbltag.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tbltag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tbltag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tbltag.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tag != nil {
		edges = append(edges, tbltag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tbltag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtag != nil {
		edges = append(edges, tbltag.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tbltag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtag {
		edges = append(edges, tbltag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tbltag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TblTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblTagMutation) ResetEdge(name string) error {
	switch name {
	case tbltag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown TblTag edge %s", name)
}

// TblUserMutation represents an operation that mutates the TblUser nodes in the graph.
type TblUserMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	firstname           *string
	lastname            *string
	email               *string
	birth_date          *time.Time
	password            *string
	is_active           *int
	addis_active        *int
	zip_code            *int
	addzip_code         *int
	address             *string
	ip_address          *string
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	role                *tbluser.Role
	clearedFields       map[string]struct{}
	_UserToken          map[string]struct{}
	removed_UserToken   map[string]struct{}
	cleared_UserToken   bool
	_UserCart           map[string]struct{}
	removed_UserCart    map[string]struct{}
	cleared_UserCart    bool
	_UserPayment        map[string]struct{}
	removed_UserPayment map[string]struct{}
	cleared_UserPayment bool
	done                bool
	oldValue            func(context.Context) (*TblUser, error)
	predicates          []predicate.TblUser
}

var _ ent.Mutation = (*TblUserMutation)(nil)

// tbluserOption allows management of the mutation configuration using functional options.
type tbluserOption func(*TblUserMutation)

// newTblUserMutation creates new mutation for the TblUser entity.
func newTblUserMutation(c config, op Op, opts ...tbluserOption) *TblUserMutation {
	m := &TblUserMutation{
		config:        c,
		op:            op,
		typ:           TypeTblUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTblUserID sets the ID field of the mutation.
func withTblUserID(id string) tbluserOption {
	return func(m *TblUserMutation) {
		var (
			err   error
			once  sync.Once
			value *TblUser
		)
		m.oldValue = func(ctx context.Context) (*TblUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TblUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTblUser sets the old TblUser of the mutation.
func withTblUser(node *TblUser) tbluserOption {
	return func(m *TblUserMutation) {
		m.oldValue = func(context.Context) (*TblUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TblUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TblUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entgen: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TblUser entities.
func (m *TblUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TblUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TblUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TblUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstname sets the "firstname" field.
func (m *TblUserMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *TblUserMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *TblUserMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *TblUserMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *TblUserMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *TblUserMutation) ResetLastname() {
	m.lastname = nil
}

// SetEmail sets the "email" field.
func (m *TblUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *TblUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *TblUserMutation) ResetEmail() {
	m.email = nil
}

// SetBirthDate sets the "birth_date" field.
func (m *TblUserMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *TblUserMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldBirthDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ClearBirthDate clears the value of the "birth_date" field.
func (m *TblUserMutation) ClearBirthDate() {
	m.birth_date = nil
	m.clearedFields[tbluser.FieldBirthDate] = struct{}{}
}

// BirthDateCleared returns if the "birth_date" field was cleared in this mutation.
func (m *TblUserMutation) BirthDateCleared() bool {
	_, ok := m.clearedFields[tbluser.FieldBirthDate]
	return ok
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *TblUserMutation) ResetBirthDate() {
	m.birth_date = nil
	delete(m.clearedFields, tbluser.FieldBirthDate)
}

// SetPassword sets the "password" field.
func (m *TblUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *TblUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *TblUserMutation) ResetPassword() {
	m.password = nil
}

// SetIsActive sets the "is_active" field.
func (m *TblUserMutation) SetIsActive(i int) {
	m.is_active = &i
	m.addis_active = nil
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *TblUserMutation) IsActive() (r int, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldIsActive(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// AddIsActive adds i to the "is_active" field.
func (m *TblUserMutation) AddIsActive(i int) {
	if m.addis_active != nil {
		*m.addis_active += i
	} else {
		m.addis_active = &i
	}
}

// AddedIsActive returns the value that was added to the "is_active" field in this mutation.
func (m *TblUserMutation) AddedIsActive() (r int, exists bool) {
	v := m.addis_active
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *TblUserMutation) ResetIsActive() {
	m.is_active = nil
	m.addis_active = nil
}

// SetZipCode sets the "zip_code" field.
func (m *TblUserMutation) SetZipCode(i int) {
	m.zip_code = &i
	m.addzip_code = nil
}

// ZipCode returns the value of the "zip_code" field in the mutation.
func (m *TblUserMutation) ZipCode() (r int, exists bool) {
	v := m.zip_code
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "zip_code" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldZipCode(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// AddZipCode adds i to the "zip_code" field.
func (m *TblUserMutation) AddZipCode(i int) {
	if m.addzip_code != nil {
		*m.addzip_code += i
	} else {
		m.addzip_code = &i
	}
}

// AddedZipCode returns the value that was added to the "zip_code" field in this mutation.
func (m *TblUserMutation) AddedZipCode() (r int, exists bool) {
	v := m.addzip_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearZipCode clears the value of the "zip_code" field.
func (m *TblUserMutation) ClearZipCode() {
	m.zip_code = nil
	m.addzip_code = nil
	m.clearedFields[tbluser.FieldZipCode] = struct{}{}
}

// ZipCodeCleared returns if the "zip_code" field was cleared in this mutation.
func (m *TblUserMutation) ZipCodeCleared() bool {
	_, ok := m.clearedFields[tbluser.FieldZipCode]
	return ok
}

// ResetZipCode resets all changes to the "zip_code" field.
func (m *TblUserMutation) ResetZipCode() {
	m.zip_code = nil
	m.addzip_code = nil
	delete(m.clearedFields, tbluser.FieldZipCode)
}

// SetAddress sets the "address" field.
func (m *TblUserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *TblUserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *TblUserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[tbluser.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *TblUserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[tbluser.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *TblUserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, tbluser.FieldAddress)
}

// SetIPAddress sets the "ip_address" field.
func (m *TblUserMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *TblUserMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *TblUserMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[tbluser.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *TblUserMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[tbluser.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *TblUserMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, tbluser.FieldIPAddress)
}

// SetCreatedAt sets the "created_at" field.
func (m *TblUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TblUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TblUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TblUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TblUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TblUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TblUserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TblUserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TblUserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tbluser.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TblUserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tbluser.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TblUserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tbluser.FieldDeletedAt)
}

// SetRole sets the "role" field.
func (m *TblUserMutation) SetRole(t tbluser.Role) {
	m.role = &t
}

// Role returns the value of the "role" field in the mutation.
func (m *TblUserMutation) Role() (r tbluser.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the TblUser entity.
// If the TblUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TblUserMutation) OldRole(ctx context.Context) (v tbluser.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *TblUserMutation) ResetRole() {
	m.role = nil
}

// AddUserTokenIDs adds the "UserToken" edge to the TblAuthToken entity by ids.
func (m *TblUserMutation) AddUserTokenIDs(ids ...string) {
	if m._UserToken == nil {
		m._UserToken = make(map[string]struct{})
	}
	for i := range ids {
		m._UserToken[ids[i]] = struct{}{}
	}
}

// ClearUserToken clears the "UserToken" edge to the TblAuthToken entity.
func (m *TblUserMutation) ClearUserToken() {
	m.cleared_UserToken = true
}

// UserTokenCleared reports if the "UserToken" edge to the TblAuthToken entity was cleared.
func (m *TblUserMutation) UserTokenCleared() bool {
	return m.cleared_UserToken
}

// RemoveUserTokenIDs removes the "UserToken" edge to the TblAuthToken entity by IDs.
func (m *TblUserMutation) RemoveUserTokenIDs(ids ...string) {
	if m.removed_UserToken == nil {
		m.removed_UserToken = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._UserToken, ids[i])
		m.removed_UserToken[ids[i]] = struct{}{}
	}
}

// RemovedUserToken returns the removed IDs of the "UserToken" edge to the TblAuthToken entity.
func (m *TblUserMutation) RemovedUserTokenIDs() (ids []string) {
	for id := range m.removed_UserToken {
		ids = append(ids, id)
	}
	return
}

// UserTokenIDs returns the "UserToken" edge IDs in the mutation.
func (m *TblUserMutation) UserTokenIDs() (ids []string) {
	for id := range m._UserToken {
		ids = append(ids, id)
	}
	return
}

// ResetUserToken resets all changes to the "UserToken" edge.
func (m *TblUserMutation) ResetUserToken() {
	m._UserToken = nil
	m.cleared_UserToken = false
	m.removed_UserToken = nil
}

// AddUserCartIDs adds the "UserCart" edge to the TblCart entity by ids.
func (m *TblUserMutation) AddUserCartIDs(ids ...string) {
	if m._UserCart == nil {
		m._UserCart = make(map[string]struct{})
	}
	for i := range ids {
		m._UserCart[ids[i]] = struct{}{}
	}
}

// ClearUserCart clears the "UserCart" edge to the TblCart entity.
func (m *TblUserMutation) ClearUserCart() {
	m.cleared_UserCart = true
}

// UserCartCleared reports if the "UserCart" edge to the TblCart entity was cleared.
func (m *TblUserMutation) UserCartCleared() bool {
	return m.cleared_UserCart
}

// RemoveUserCartIDs removes the "UserCart" edge to the TblCart entity by IDs.
func (m *TblUserMutation) RemoveUserCartIDs(ids ...string) {
	if m.removed_UserCart == nil {
		m.removed_UserCart = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._UserCart, ids[i])
		m.removed_UserCart[ids[i]] = struct{}{}
	}
}

// RemovedUserCart returns the removed IDs of the "UserCart" edge to the TblCart entity.
func (m *TblUserMutation) RemovedUserCartIDs() (ids []string) {
	for id := range m.removed_UserCart {
		ids = append(ids, id)
	}
	return
}

// UserCartIDs returns the "UserCart" edge IDs in the mutation.
func (m *TblUserMutation) UserCartIDs() (ids []string) {
	for id := range m._UserCart {
		ids = append(ids, id)
	}
	return
}

// ResetUserCart resets all changes to the "UserCart" edge.
func (m *TblUserMutation) ResetUserCart() {
	m._UserCart = nil
	m.cleared_UserCart = false
	m.removed_UserCart = nil
}

// AddUserPaymentIDs adds the "UserPayment" edge to the TblPayment entity by ids.
func (m *TblUserMutation) AddUserPaymentIDs(ids ...string) {
	if m._UserPayment == nil {
		m._UserPayment = make(map[string]struct{})
	}
	for i := range ids {
		m._UserPayment[ids[i]] = struct{}{}
	}
}

// ClearUserPayment clears the "UserPayment" edge to the TblPayment entity.
func (m *TblUserMutation) ClearUserPayment() {
	m.cleared_UserPayment = true
}

// UserPaymentCleared reports if the "UserPayment" edge to the TblPayment entity was cleared.
func (m *TblUserMutation) UserPaymentCleared() bool {
	return m.cleared_UserPayment
}

// RemoveUserPaymentIDs removes the "UserPayment" edge to the TblPayment entity by IDs.
func (m *TblUserMutation) RemoveUserPaymentIDs(ids ...string) {
	if m.removed_UserPayment == nil {
		m.removed_UserPayment = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._UserPayment, ids[i])
		m.removed_UserPayment[ids[i]] = struct{}{}
	}
}

// RemovedUserPayment returns the removed IDs of the "UserPayment" edge to the TblPayment entity.
func (m *TblUserMutation) RemovedUserPaymentIDs() (ids []string) {
	for id := range m.removed_UserPayment {
		ids = append(ids, id)
	}
	return
}

// UserPaymentIDs returns the "UserPayment" edge IDs in the mutation.
func (m *TblUserMutation) UserPaymentIDs() (ids []string) {
	for id := range m._UserPayment {
		ids = append(ids, id)
	}
	return
}

// ResetUserPayment resets all changes to the "UserPayment" edge.
func (m *TblUserMutation) ResetUserPayment() {
	m._UserPayment = nil
	m.cleared_UserPayment = false
	m.removed_UserPayment = nil
}

// Where appends a list predicates to the TblUserMutation builder.
func (m *TblUserMutation) Where(ps ...predicate.TblUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TblUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TblUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TblUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TblUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TblUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TblUser).
func (m *TblUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TblUserMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.firstname != nil {
		fields = append(fields, tbluser.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, tbluser.FieldLastname)
	}
	if m.email != nil {
		fields = append(fields, tbluser.FieldEmail)
	}
	if m.birth_date != nil {
		fields = append(fields, tbluser.FieldBirthDate)
	}
	if m.password != nil {
		fields = append(fields, tbluser.FieldPassword)
	}
	if m.is_active != nil {
		fields = append(fields, tbluser.FieldIsActive)
	}
	if m.zip_code != nil {
		fields = append(fields, tbluser.FieldZipCode)
	}
	if m.address != nil {
		fields = append(fields, tbluser.FieldAddress)
	}
	if m.ip_address != nil {
		fields = append(fields, tbluser.FieldIPAddress)
	}
	if m.created_at != nil {
		fields = append(fields, tbluser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tbluser.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, tbluser.FieldDeletedAt)
	}
	if m.role != nil {
		fields = append(fields, tbluser.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TblUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tbluser.FieldFirstname:
		return m.Firstname()
	case tbluser.FieldLastname:
		return m.Lastname()
	case tbluser.FieldEmail:
		return m.Email()
	case tbluser.FieldBirthDate:
		return m.BirthDate()
	case tbluser.FieldPassword:
		return m.Password()
	case tbluser.FieldIsActive:
		return m.IsActive()
	case tbluser.FieldZipCode:
		return m.ZipCode()
	case tbluser.FieldAddress:
		return m.Address()
	case tbluser.FieldIPAddress:
		return m.IPAddress()
	case tbluser.FieldCreatedAt:
		return m.CreatedAt()
	case tbluser.FieldUpdatedAt:
		return m.UpdatedAt()
	case tbluser.FieldDeletedAt:
		return m.DeletedAt()
	case tbluser.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TblUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tbluser.FieldFirstname:
		return m.OldFirstname(ctx)
	case tbluser.FieldLastname:
		return m.OldLastname(ctx)
	case tbluser.FieldEmail:
		return m.OldEmail(ctx)
	case tbluser.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case tbluser.FieldPassword:
		return m.OldPassword(ctx)
	case tbluser.FieldIsActive:
		return m.OldIsActive(ctx)
	case tbluser.FieldZipCode:
		return m.OldZipCode(ctx)
	case tbluser.FieldAddress:
		return m.OldAddress(ctx)
	case tbluser.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case tbluser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tbluser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tbluser.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tbluser.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown TblUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tbluser.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case tbluser.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case tbluser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case tbluser.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case tbluser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case tbluser.FieldIsActive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case tbluser.FieldZipCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case tbluser.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case tbluser.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case tbluser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tbluser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tbluser.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tbluser.FieldRole:
		v, ok := value.(tbluser.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown TblUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TblUserMutation) AddedFields() []string {
	var fields []string
	if m.addis_active != nil {
		fields = append(fields, tbluser.FieldIsActive)
	}
	if m.addzip_code != nil {
		fields = append(fields, tbluser.FieldZipCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TblUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tbluser.FieldIsActive:
		return m.AddedIsActive()
	case tbluser.FieldZipCode:
		return m.AddedZipCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TblUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tbluser.FieldIsActive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsActive(v)
		return nil
	case tbluser.FieldZipCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddZipCode(v)
		return nil
	}
	return fmt.Errorf("unknown TblUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TblUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tbluser.FieldBirthDate) {
		fields = append(fields, tbluser.FieldBirthDate)
	}
	if m.FieldCleared(tbluser.FieldZipCode) {
		fields = append(fields, tbluser.FieldZipCode)
	}
	if m.FieldCleared(tbluser.FieldAddress) {
		fields = append(fields, tbluser.FieldAddress)
	}
	if m.FieldCleared(tbluser.FieldIPAddress) {
		fields = append(fields, tbluser.FieldIPAddress)
	}
	if m.FieldCleared(tbluser.FieldDeletedAt) {
		fields = append(fields, tbluser.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TblUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TblUserMutation) ClearField(name string) error {
	switch name {
	case tbluser.FieldBirthDate:
		m.ClearBirthDate()
		return nil
	case tbluser.FieldZipCode:
		m.ClearZipCode()
		return nil
	case tbluser.FieldAddress:
		m.ClearAddress()
		return nil
	case tbluser.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case tbluser.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown TblUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TblUserMutation) ResetField(name string) error {
	switch name {
	case tbluser.FieldFirstname:
		m.ResetFirstname()
		return nil
	case tbluser.FieldLastname:
		m.ResetLastname()
		return nil
	case tbluser.FieldEmail:
		m.ResetEmail()
		return nil
	case tbluser.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case tbluser.FieldPassword:
		m.ResetPassword()
		return nil
	case tbluser.FieldIsActive:
		m.ResetIsActive()
		return nil
	case tbluser.FieldZipCode:
		m.ResetZipCode()
		return nil
	case tbluser.FieldAddress:
		m.ResetAddress()
		return nil
	case tbluser.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case tbluser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tbluser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tbluser.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tbluser.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown TblUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TblUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._UserToken != nil {
		edges = append(edges, tbluser.EdgeUserToken)
	}
	if m._UserCart != nil {
		edges = append(edges, tbluser.EdgeUserCart)
	}
	if m._UserPayment != nil {
		edges = append(edges, tbluser.EdgeUserPayment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TblUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tbluser.EdgeUserToken:
		ids := make([]ent.Value, 0, len(m._UserToken))
		for id := range m._UserToken {
			ids = append(ids, id)
		}
		return ids
	case tbluser.EdgeUserCart:
		ids := make([]ent.Value, 0, len(m._UserCart))
		for id := range m._UserCart {
			ids = append(ids, id)
		}
		return ids
	case tbluser.EdgeUserPayment:
		ids := make([]ent.Value, 0, len(m._UserPayment))
		for id := range m._UserPayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TblUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_UserToken != nil {
		edges = append(edges, tbluser.EdgeUserToken)
	}
	if m.removed_UserCart != nil {
		edges = append(edges, tbluser.EdgeUserCart)
	}
	if m.removed_UserPayment != nil {
		edges = append(edges, tbluser.EdgeUserPayment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TblUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tbluser.EdgeUserToken:
		ids := make([]ent.Value, 0, len(m.removed_UserToken))
		for id := range m.removed_UserToken {
			ids = append(ids, id)
		}
		return ids
	case tbluser.EdgeUserCart:
		ids := make([]ent.Value, 0, len(m.removed_UserCart))
		for id := range m.removed_UserCart {
			ids = append(ids, id)
		}
		return ids
	case tbluser.EdgeUserPayment:
		ids := make([]ent.Value, 0, len(m.removed_UserPayment))
		for id := range m.removed_UserPayment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TblUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_UserToken {
		edges = append(edges, tbluser.EdgeUserToken)
	}
	if m.cleared_UserCart {
		edges = append(edges, tbluser.EdgeUserCart)
	}
	if m.cleared_UserPayment {
		edges = append(edges, tbluser.EdgeUserPayment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TblUserMutation) EdgeCleared(name string) bool {
	switch name {
	case tbluser.EdgeUserToken:
		return m.cleared_UserToken
	case tbluser.EdgeUserCart:
		return m.cleared_UserCart
	case tbluser.EdgeUserPayment:
		return m.cleared_UserPayment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TblUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TblUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TblUserMutation) ResetEdge(name string) error {
	switch name {
	case tbluser.EdgeUserToken:
		m.ResetUserToken()
		return nil
	case tbluser.EdgeUserCart:
		m.ResetUserCart()
		return nil
	case tbluser.EdgeUserPayment:
		m.ResetUserPayment()
		return nil
	}
	return fmt.Errorf("unknown TblUser edge %s", name)
}
